SCRIPT  /home/syphez/.vim/bundle/emmet-vim/autoload/emmet/util.vim
Sourced 1 time
Total time:   0.000257
 Self time:   0.000257

count  total (s)   self (s)
                            "==============================================================================
                            " region utils
                            "==============================================================================
                            " deleteContent : delete content in region
                            "   if region make from between '<foo>' and '</foo>'
                            "   --------------------
                            "   begin:<foo>
                            "   </foo>:end
                            "   --------------------
                            "   this function make the content as following
                            "   --------------------
                            "   begin::end
                            "   --------------------
    1              0.000009 function! emmet#util#deleteContent(region) abort
                              let lines = getline(a:region[0][0], a:region[1][0])
                              call setpos('.', [0, a:region[0][0], a:region[0][1], 0])
                              silent! exe 'delete '.(a:region[1][0] - a:region[0][0])
                              call setline(line('.'), lines[0][:a:region[0][1]-2] . lines[-1][a:region[1][1]])
                            endfunction
                            
                            " change_content : change content in region
                            "   if region make from between '<foo>' and '</foo>'
                            "   --------------------
                            "   begin:<foo>
                            "   </foo>:end
                            "   --------------------
                            "   and content is
                            "   --------------------
                            "   foo
                            "   bar
                            "   baz
                            "   --------------------
                            "   this function make the content as following
                            "   --------------------
                            "   begin:foo
                            "   bar
                            "   baz:end
                            "   --------------------
    1              0.000002 function! emmet#util#setContent(region, content) abort
                              let newlines = split(a:content, '\n', 1)
                              let oldlines = getline(a:region[0][0], a:region[1][0])
                              call setpos('.', [0, a:region[0][0], a:region[0][1], 0])
                              silent! exe 'delete '.(a:region[1][0] - a:region[0][0])
                              if len(newlines) == 0
                                let tmp = ''
                                if a:region[0][1] > 1
                                  let tmp = oldlines[0][:a:region[0][1]-2]
                                endif
                                if a:region[1][1] >= 1
                                  let tmp .= oldlines[-1][a:region[1][1]:]
                                endif
                                call setline(line('.'), tmp)
                              elseif len(newlines) == 1
                                if a:region[0][1] > 1
                                  let newlines[0] = oldlines[0][:a:region[0][1]-2] . newlines[0]
                                endif
                                if a:region[1][1] >= 1
                                  let newlines[0] .= oldlines[-1][a:region[1][1]:]
                                endif
                                call setline(line('.'), newlines[0])
                              else
                                if a:region[0][1] > 1
                                  let newlines[0] = oldlines[0][:a:region[0][1]-2] . newlines[0]
                                endif
                                if a:region[1][1] >= 1
                                  let newlines[-1] .= oldlines[-1][a:region[1][1]:]
                                endif
                                call setline(line('.'), newlines[0])
                                call append(line('.'), newlines[1:])
                              endif
                            endfunction
                            
                            " select_region : select region
                            "   this function make a selection of region
    1              0.000002 function! emmet#util#selectRegion(region) abort
                              call setpos('.', [0, a:region[1][0], a:region[1][1], 0])
                              normal! v
                              call setpos('.', [0, a:region[0][0], a:region[0][1], 0])
                            endfunction
                            
                            " point_in_region : check point is in the region
                            "   this function return 0 or 1
    1              0.000002 function! emmet#util#pointInRegion(point, region) abort
                              if !emmet#util#regionIsValid(a:region) | return 0 | endif
                              if a:region[0][0] > a:point[0] | return 0 | endif
                              if a:region[1][0] < a:point[0] | return 0 | endif
                              if a:region[0][0] == a:point[0] && a:region[0][1] > a:point[1] | return 0 | endif
                              if a:region[1][0] == a:point[0] && a:region[1][1] < a:point[1] | return 0 | endif
                              return 1
                            endfunction
                            
                            " cursor_in_region : check cursor is in the region
                            "   this function return 0 or 1
    1              0.000002 function! emmet#util#cursorInRegion(region) abort
                              if !emmet#util#regionIsValid(a:region) | return 0 | endif
                              let cur = emmet#util#getcurpos()[1:2]
                              return emmet#util#pointInRegion(cur, a:region)
                            endfunction
                            
                            " region_is_valid : check region is valid
                            "   this function return 0 or 1
    1              0.000002 function! emmet#util#regionIsValid(region) abort
                              if a:region[0][0] == 0 || a:region[1][0] == 0 | return 0 | endif
                              return 1
                            endfunction
                            
                            " search_region : make region from pattern which is composing start/end
                            "   this function return array of position
    1              0.000002 function! emmet#util#searchRegion(start, end) abort
                              let b = searchpairpos(a:start, '', a:end, 'bcnW')
                              if b == [0, 0]
                                return [searchpairpos(a:start, '', a:end, 'bnW'), searchpairpos(a:start, '\%#', a:end, 'nW')]
                              else
                                return [b, searchpairpos(a:start, '', a:end. '', 'nW')]
                              endif
                            endfunction
                            
                            " get_content : get content in region
                            "   this function return string in region
    1              0.000003 function! emmet#util#getContent(region) abort
                              if !emmet#util#regionIsValid(a:region)
                                return ''
                              endif
                              let lines = getline(a:region[0][0], a:region[1][0])
                              if a:region[0][0] == a:region[1][0]
                                let lines[0] = lines[0][a:region[0][1]-1:a:region[1][1]-1]
                              else
                                let lines[0] = lines[0][a:region[0][1]-1:]
                                let lines[-1] = lines[-1][:a:region[1][1]-1]
                              endif
                              return join(lines, "\n")
                            endfunction
                            
                            " region_in_region : check region is in the region
                            "   this function return 0 or 1
    1              0.000002 function! emmet#util#regionInRegion(outer, inner) abort
                              if !emmet#util#regionIsValid(a:inner) || !emmet#util#regionIsValid(a:outer)
                                return 0
                              endif
                              return emmet#util#pointInRegion(a:inner[0], a:outer) && emmet#util#pointInRegion(a:inner[1], a:outer)
                            endfunction
                            
                            " get_visualblock : get region of visual block
                            "   this function return region of visual block
    1              0.000002 function! emmet#util#getVisualBlock() abort
                              return [[line("'<"), col("'<")], [line("'>"), col("'>")]]
                            endfunction
                            
                            "==============================================================================
                            " html utils
                            "==============================================================================
    1              0.000002 function! emmet#util#getContentFromURL(url) abort
                              let res = system(printf('%s -i %s', g:emmet_curl_command, shellescape(substitute(a:url, '#.*', '', ''))))
                              while res =~# '^HTTP/1.\d 3' || res =~# '^HTTP/1\.\d 200 Connection established' || res =~# '^HTTP/1\.\d 100 Continue'
                                let pos = stridx(res, "\r\n\r\n")
                                if pos != -1
                                  let res = strpart(res, pos+4)
                                else
                                  let pos = stridx(res, "\n\n")
                                  let res = strpart(res, pos+2)
                                endif
                              endwhile
                              let pos = stridx(res, "\r\n\r\n")
                              if pos != -1
                                let content = strpart(res, pos+4)
                              else
                                let pos = stridx(res, "\n\n")
                                let content = strpart(res, pos+2)
                              endif
                              let header = res[:pos-1]
                              let charset = matchstr(content, '<meta[^>]\+content=["''][^;"'']\+;\s*charset=\zs[^;"'']\+\ze["''][^>]*>')
                              if len(charset) == 0
                                let charset = matchstr(content, '<meta\s\+charset=["'']\?\zs[^"'']\+\ze["'']\?[^>]*>')
                              endif
                              if len(charset) == 0
                                let charset = matchstr(header, '\nContent-Type:.* charset=[''"]\?\zs[^''";\n]\+\ze')
                              endif
                              if len(charset) == 0
                                let s1 = len(split(content, '?'))
                                let utf8 = iconv(content, 'utf-8', &encoding)
                                let s2 = len(split(utf8, '?'))
                                return (s2 == s1 || s2 >= s1 * 2) ? utf8 : content
                              endif
                              return iconv(content, charset, &encoding)
                            endfunction
                            
    1              0.000002 function! emmet#util#getTextFromHTML(buf) abort
                              let threshold_len = 100
                              let threshold_per = 0.1
                              let buf = a:buf
                            
                              let buf = strpart(buf, stridx(buf, '</head>'))
                              let buf = substitute(buf, '<style[^>]*>.\{-}</style>', '', 'g')
                              let buf = substitute(buf, '<script[^>]*>.\{-}</script>', '', 'g')
                              let res = ''
                              let max = 0
                              let mx = '\(<td[^>]\{-}>\)\|\(<\/td>\)\|\(<div[^>]\{-}>\)\|\(<\/div>\)'
                              let m = split(buf, mx)
                              for str in m
                                let c = split(str, '<[^>]*?>')
                                let str = substitute(str, '<[^>]\{-}>', ' ', 'g')
                                let str = substitute(str, '&gt;', '>', 'g')
                                let str = substitute(str, '&lt;', '<', 'g')
                                let str = substitute(str, '&quot;', '"', 'g')
                                let str = substitute(str, '&apos;', '''', 'g')
                                let str = substitute(str, '&nbsp;', ' ', 'g')
                                let str = substitute(str, '&yen;', '\&#65509;', 'g')
                                let str = substitute(str, '&amp;', '\&', 'g')
                                let str = substitute(str, '^\s*\(.*\)\s*$', '\1', '')
                                let str = substitute(str, '\s\+', ' ', 'g')
                                let l = len(str)
                                if l > threshold_len
                                  let per = (l+0.0) / len(c)
                                  if max < l && per > threshold_per
                                    let max = l
                                    let res = str
                                  endif
                                endif
                              endfor
                              let res = substitute(res, '^\s*\(.*\)\s*$', '\1', 'g')
                              return res
                            endfunction
                            
    1              0.000002 function! emmet#util#getImageSize(fn) abort
                              let fn = a:fn
                            
                              if emmet#util#isImageMagickInstalled()
                                return emmet#util#imageSizeWithImageMagick(fn)
                              endif
                            
                              if filereadable(fn)
                                let hex = substitute(system('xxd -p "'.fn.'"'), '\n', '', 'g')
                              else
                                if fn !~# '^\w\+://'
                                  let path = fnamemodify(expand('%'), ':p:gs?\\?/?')
                                  if has('win32') || has('win64') | 
                                    let path = tolower(path)
                                  endif
                                  for k in keys(g:emmet_docroot)
                                    let root = fnamemodify(k, ':p:gs?\\?/?')
                                    if has('win32') || has('win64') | 
                                      let root = tolower(root)
                                    endif
                                    if stridx(path, root) == 0
                                      let v = g:emmet_docroot[k]
                                      let fn = (len(v) == 0 ? k : v) . fn
                                      break
                                    endif
                                  endfor
                                endif
                                let hex = substitute(system(g:emmet_curl_command.' "'.fn.'" | xxd -p'), '\n', '', 'g')
                              endif
                            
                              let [width, height] = [-1, -1]
                              if hex =~# '^89504e470d0a1a0a'
                                let width = eval('0x'.hex[32:39])
                                let height = eval('0x'.hex[40:47])
                              endif
                              if hex =~# '^ffd8'
                                let pos = 4
                                while pos < len(hex)
                                  let bs = hex[pos+0:pos+3]
                                  let pos += 4
                                  if bs ==# 'ffc0' || bs ==# 'ffc2'
                                    let pos += 6
                                    let height = eval('0x'.hex[pos+0:pos+1])*256 + eval('0x'.hex[pos+2:pos+3])
                                    let pos += 4
                                    let width = eval('0x'.hex[pos+0:pos+1])*256 + eval('0x'.hex[pos+2:pos+3])
                                    break
                                  elseif bs =~# 'ffd[9a]'
                                    break
                                  elseif bs =~# 'ff\(e[0-9a-e]\|fe\|db\|dd\|c4\)'
                                    let pos += (eval('0x'.hex[pos+0:pos+1])*256 + eval('0x'.hex[pos+2:pos+3])) * 2
                                  endif
                                endwhile
                              endif
                              if hex =~# '^47494638'
                                let width = eval('0x'.hex[14:15].hex[12:13])
                                let height = eval('0x'.hex[18:19].hex[16:17])
                              endif
                            
                              return [width, height]
                            endfunction
                            
    1              0.000003 function! emmet#util#imageSizeWithImageMagick(fn) abort
                              let img_info = system('identify -format "%wx%h" "'.a:fn.'"')
                              let img_size = split(substitute(img_info, '\n', '', ''), 'x')
                              if len(img_size) != 2
                                return [-1, -1]
                              endif
                              return img_size
                            endfunction
                            
    1              0.000002 function! emmet#util#isImageMagickInstalled() abort
                              if !get(g:, 'emmet_use_identify', 1)
                                return 0
                              endif
                              return executable('identify')
                            endfunction
                            
    1              0.000002 function! emmet#util#unique(arr) abort
                              let m = {}
                              let r = []
                              for i in a:arr
                                if !has_key(m, i)
                                  let m[i] = 1
                                  call add(r, i)
                                endif
                              endfor
                              return r
                            endfunction
                            
    1              0.000007 let s:seed = localtime()
    1              0.000003 function! emmet#util#srand(seed) abort
                              let s:seed = a:seed
                            endfunction
                            
    1              0.000001 function! emmet#util#rand() abort
                              let s:seed = s:seed * 214013 + 2531011
                              return (s:seed < 0 ? s:seed - 0x80000000 : s:seed) / 0x10000 % 0x8000
                            endfunction
                            
    1              0.000002 function! emmet#util#cache(name, ...) abort
                              let content = get(a:000, 0, '')
                              let dir = expand('~/.emmet/cache')
                              if !isdirectory(dir)
                                call mkdir(dir, 'p', 0700)
                              endif
                              let file = dir . '/' . substitute(a:name, '\W', '_', 'g')
                              if len(content) == 0
                                if !filereadable(file)
                                  return ''
                                endif
                            	return join(readfile(file), "\n")
                              endif
                              call writefile(split(content, "\n"), file)
                            endfunction
                            
    1              0.000002 function! emmet#util#getcurpos() abort
                              let pos = getpos('.')
                              if mode(0) ==# 'i' && pos[2] > 0
                                let pos[2] -=1
                              endif
                              return pos
                            endfunction
                            
    1              0.000002 function! emmet#util#closePopup() abort
                              return pumvisible() ? "\<c-e>" : ''
                            endfunction

SCRIPT  /home/syphez/.vim/bundle/emmet-vim/autoload/emmet.vim
Sourced 1 time
Total time:   0.001951
 Self time:   0.001951

count  total (s)   self (s)
                            "=============================================================================
                            " emmet.vim
                            " Author: Yasuhiro Matsumoto <mattn.jp@gmail.com>
                            " Last Change: 26-Jul-2015.
                            
    1              0.000007 let s:save_cpo = &cpoptions
    1              0.000012 set cpoptions&vim
                            
    1              0.000003 let s:filtermx = '|\(\%(bem\|html\|haml\|slim\|e\|c\|s\|fc\|xsl\|t\|\/[^ ]\+\)\s*,\{0,1}\s*\)*$'
                            
    1              0.000002 function! emmet#getExpandos(type, key) abort
                              let expandos = emmet#getResource(a:type, 'expandos', {})
                              if has_key(expandos, a:key)
                                return expandos[a:key]
                              endif
                              return a:key
                            endfunction
                            
    1              0.000002 function! emmet#splitFilterArg(filters) abort
                              for f in a:filters
                                if f =~# '^/'
                                  return f[1:]
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000002 function! emmet#useFilter(filters, filter) abort
                              for f in a:filters
                                if a:filter ==# '/' && f =~# '^/'
                                  return 1
                                elseif f ==# a:filter
                                  return 1
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000002 function! emmet#getIndentation(...) abort
                              if a:0 > 0
                                let type = a:1
                              else
                                let type = emmet#getFileType()
                              endif
                              if has_key(s:emmet_settings, type) && has_key(s:emmet_settings[type], 'indentation')
                                let indent = s:emmet_settings[type].indentation
                              elseif has_key(s:emmet_settings, 'indentation')
                                let indent = s:emmet_settings.indentation
                              elseif has_key(s:emmet_settings.variables, 'indentation')
                                let indent = s:emmet_settings.variables.indentation
                              else
                                let sw = exists('*shiftwidth') ? shiftwidth() : &l:shiftwidth
                                let indent = (&l:expandtab || &l:tabstop !=# sw) ? repeat(' ', sw) : "\t"
                              endif
                              return indent
                            endfunction
                            
    1              0.000002 function! emmet#getBaseType(type) abort
                              if !has_key(s:emmet_settings, a:type)
                                return ''
                              endif
                              if !has_key(s:emmet_settings[a:type], 'extends')
                                return a:type
                              endif
                              let extends = s:emmet_settings[a:type].extends
                              if type(extends) ==# 1
                                let tmp = split(extends, '\s*,\s*')
                                let ext = tmp[0]
                              else
                                let ext = extends[0]
                              endif
                              if a:type !=# ext
                                return emmet#getBaseType(ext)
                              endif
                              return ''
                            endfunction
                            
    1              0.000002 function! emmet#isExtends(type, extend) abort
                              if a:type ==# a:extend
                                return 1
                              endif
                              if !has_key(s:emmet_settings, a:type)
                                return 0
                              endif
                              if !has_key(s:emmet_settings[a:type], 'extends')
                                return 0
                              endif
                              let extends = s:emmet_settings[a:type].extends
                              if type(extends) ==# 1
                                let tmp = split(extends, '\s*,\s*')
                                unlet! extends
                                let extends = tmp
                              endif
                              for ext in extends
                                if a:extend ==# ext
                                  return 1
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000002 function! emmet#parseIntoTree(abbr, type) abort
                              let abbr = a:abbr
                              let type = a:type
                              return emmet#lang#{emmet#lang#type(type)}#parseIntoTree(abbr, type)
                            endfunction
                            
    1              0.000002 function! emmet#expandAbbrIntelligent(feedkey) abort
                              if !emmet#isExpandable()
                                return a:feedkey
                              endif
                              return "\<plug>(emmet-expand-abbr)"
                            endfunction
                            
    1              0.000002 function! emmet#isExpandable() abort
                              let line = getline('.')
                              if col('.') < len(line)
                                let line = matchstr(line, '^\(.*\%'.col('.').'c\)')
                              endif
                              let part = matchstr(line, '\(\S.*\)$')
                              let type = emmet#getFileType()
                              let ftype = emmet#lang#exists(type) ? type : 'html'
                              let part = emmet#lang#{ftype}#findTokens(part)
                              return len(part) > 0
                            endfunction
                            
    1              0.000002 function! emmet#mergeConfig(lhs, rhs) abort
                              let [lhs, rhs] = [a:lhs, a:rhs]
                              if type(lhs) ==# 3
                                if type(rhs) ==# 3
                                  let lhs += rhs
                                  if len(lhs)
                                    call remove(lhs, 0, len(lhs)-1)
                                  endif
                                  for rhi in rhs
                                    call add(lhs, rhs[rhi])
                                  endfor
                                elseif type(rhs) ==# 4
                                  let lhs += map(keys(rhs), '{v:val : rhs[v:val]}')
                                endif
                              elseif type(lhs) ==# 4
                                if type(rhs) ==# 3
                                  for V in rhs
                                    if type(V) != 4
                                      continue
                                    endif
                                    for k in keys(V)
                                      let lhs[k] = V[k]
                                    endfor
                                  endfor
                                elseif type(rhs) ==# 4
                                  for key in keys(rhs)
                                    if type(rhs[key]) ==# 3
                                      if !has_key(lhs, key)
                                        let lhs[key] = []
                                      endif
                                      if type(lhs[key]) == 3
                                        let lhs[key] += rhs[key]
                                      elseif type(lhs[key]) == 4
                                        for k in keys(rhs[key])
                                          let lhs[key][k] = rhs[key][k]
                                        endfor
                                      endif
                                    elseif type(rhs[key]) ==# 4
                                      if has_key(lhs, key)
                                        call emmet#mergeConfig(lhs[key], rhs[key])
                                      else
                                        let lhs[key] = rhs[key]
                                      endif
                                    else
                                      let lhs[key] = rhs[key]
                                    endif
                                  endfor
                                endif
                              endif
                            endfunction
                            
    1              0.000002 function! emmet#newNode() abort
                              return { 'name': '', 'attr': {}, 'child': [], 'snippet': '', 'basevalue': 0, 'basedirect': 1, 'multiplier': 1, 'parent': {}, 'value': '', 'pos': 0, 'important': 0, 'attrs_order': ['id', 'class'], 'block': 0, 'empty': 0 }
                            endfunction
                            
    1              0.000003 function! s:itemno(itemno, current) abort
                              let current = a:current
                              if current.basedirect > 0
                                if current.basevalue ==# 0
                                  return a:itemno
                                else
                                  return current.basevalue - 1 + a:itemno
                                endif
                              else
                                if current.basevalue ==# 0
                                  return current.multiplier - 1 - a:itemno
                                else
                                  return current.multiplier + current.basevalue - 2 - a:itemno
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! emmet#toString(...) abort
                              let current = a:1
                              if a:0 > 1
                                let type = a:2
                              else
                                let type = &filetype
                              endif
                              if len(type) ==# 0 | let type = 'html' | endif
                              if a:0 > 2
                                let inline = a:3
                              else
                                let inline = 0
                              endif
                              if a:0 > 3
                                if type(a:4) ==# 1
                                  let filters = split(a:4, '\s*,\s*')
                                else
                                  let filters = a:4
                                endif
                              else
                                let filters = ['html']
                              endif
                              if a:0 > 4
                                let group_itemno = a:5
                              else
                                let group_itemno = 0
                              endif
                              if a:0 > 5
                                let indent = a:6
                              else
                                let indent = ''
                              endif
                            
                              let dollar_expr = emmet#getResource(type, 'dollar_expr', 1)
                              let itemno = 0
                              let str = ''
                              let rtype = emmet#lang#type(type)
                              while itemno < current.multiplier
                                if len(current.name)
                                  if current.multiplier ==# 1
                                    let inner = emmet#lang#{rtype}#toString(s:emmet_settings, current, type, inline, filters, s:itemno(group_itemno, current), indent)
                                  else
                                    let inner = emmet#lang#{rtype}#toString(s:emmet_settings, current, type, inline, filters, s:itemno(itemno, current), indent)
                                  endif
                                  if current.multiplier > 1
                                    let inner = substitute(inner, '\$#', '$line'.(itemno+1).'$', 'g')
                                  endif
                                  let str .= inner
                                else
                                  let snippet = current.snippet
                                  if len(snippet) ==# 0
                                    let snippets = emmet#getResource(type, 'snippets', {})
                                    if !empty(snippets) && has_key(snippets, 'emmet_snippet')
                                      let snippet = snippets['emmet_snippet']
                                    endif
                                  endif
                                  if len(snippet) > 0
                                    let tmp = snippet
                                    let tmp = substitute(tmp, '\${emmet_name}', current.name, 'g')
                                    let snippet_node = emmet#newNode()
                                    let snippet_node.value = '{'.tmp.'}'
                                    let snippet_node.important = current.important
                                    let snippet_node.multiplier = current.multiplier
                                    let str .= emmet#lang#{rtype}#toString(s:emmet_settings, snippet_node, type, inline, filters, s:itemno(group_itemno, current), indent)
                                    if current.multiplier > 1
                                      let str .= "\n"
                                    endif
                                  else
                                    if len(current.name)
                                      let str .= current.name
                                    endif
                                    if len(current.value)
                                      let text = current.value[1:-2]
                                      if dollar_expr
                                        " TODO: regexp engine specified
                                        if exists('&regexpengine')
                                          let text = substitute(text, '\%#=1\%(\\\)\@\<!\(\$\+\)\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d", max([itemno, group_itemno])+1).submatch(2)', 'g')
                                        else
                                          let text = substitute(text, '\%(\\\)\@\<!\(\$\+\)\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d", max([itemno, group_itemno])+1).submatch(2)', 'g')
                                        endif
                                        let text = substitute(text, '\${nr}', "\n", 'g')
                                        let text = substitute(text, '\\\$', '$', 'g')
                                      endif
                                      let str .= text
                                    endif
                                  endif
                                  let inner = ''
                                  if len(current.child)
                                    for n in current.child
                                      let inner .= emmet#toString(n, type, inline, filters, s:itemno(group_itemno, n), indent)
                                    endfor
                                  else
                                    let inner = current.value[1:-2]
                                  endif
                                  let inner = substitute(inner, "\n", "\n" . indent, 'g')
                                  let str = substitute(str, '\${child}', inner, '')
                                endif
                                let itemno = itemno + 1
                              endwhile
                              return str
                            endfunction
                            
    1              0.000002 function! emmet#getSettings() abort
                              return s:emmet_settings
                            endfunction
                            
    1              0.000002 function! emmet#getFilters(type) abort
                              let filterstr = emmet#getResource(a:type, 'filters', '')
                              return split(filterstr, '\s*,\s*')
                            endfunction
                            
    1              0.000003 function! emmet#getResource(type, name, default) abort
                              if exists('b:emmet_' . a:name)
                                return get(b:, 'emmet_' . a:name)
                              endif
                              let global = {}
                              if has_key(s:emmet_settings, '*') && has_key(s:emmet_settings['*'], a:name)
                                let global = extend(global, s:emmet_settings['*'][a:name])
                              endif
                            
                              if has_key(s:emmet_settings, a:type)
                                let types = [a:type]
                              else
                                let types = split(a:type, '\.')
                              endif
                            
                              for type in types
                                if !has_key(s:emmet_settings, type)
                                  continue
                                endif
                                let ret = a:default
                            
                                if has_key(s:emmet_settings[type], 'extends')
                                  let extends = s:emmet_settings[type].extends
                                  if type(extends) ==# 1
                                    let tmp = split(extends, '\s*,\s*')
                                    unlet! extends
                                    let extends = tmp
                                  endif
                                  for ext in extends
                                    if has_key(s:emmet_settings, ext) && has_key(s:emmet_settings[ext], a:name)
                                      if type(ret) ==# 3 || type(ret) ==# 4
                                        call emmet#mergeConfig(ret, s:emmet_settings[ext][a:name])
                                      else
                                        let ret = s:emmet_settings[ext][a:name]
                                      endif
                                    endif
                                  endfor
                                endif
                            
                                if has_key(s:emmet_settings[type], a:name)
                                  if type(ret) ==# 3 || type(ret) ==# 4
                                    call emmet#mergeConfig(ret, s:emmet_settings[type][a:name])
                                    return extend(global, ret)
                                  else
                                    return s:emmet_settings[type][a:name]
                                  endif
                                endif
                                if !empty(ret)
                                  if type(ret) ==# 3 || type(ret) ==# 4
                                    let ret = extend(global, ret)
                                  endif
                                  return ret
                                endif
                              endfor
                            
                              let ret = a:default
                              if type(ret) ==# 3 || type(ret) ==# 4
                                let ret = extend(global, ret)
                              endif
                              return ret
                            endfunction
                            
    1              0.000002 function! emmet#getFileType(...) abort
                              let flg = get(a:000, 0, 0)
                              let type = ''
                            
                              if has_key(s:emmet_settings, &filetype)
                                let type = &filetype
                              else
                                let types = split(&filetype, '\.')
                                for part in types
                                  if emmet#lang#exists(part)
                                    let type = part
                                    break
                                  endif
                                  let base = emmet#getBaseType(part)
                                  if base !=# ''
                                    if flg
                                      let type = &filetype
                                    else
                                      let type = base
                                    endif
                                    unlet base
                                    break
                                  endif
                                endfor
                              endif
                              if type ==# 'html'
                                let pos = emmet#util#getcurpos()
                                let type = synIDattr(synID(pos[1], pos[2], 1), 'name')
                                if type =~# '^css\w'
                                  let type = 'css'
                                endif
                                if type =~# '^html\w'
                                  let type = 'html'
                                endif
                                if type =~# '^javaScript'
                                  let type = 'javascript'
                                endif
                                if len(type) ==# 0 && type =~# '^xml'
                                  let type = 'xml'
                                endif
                              endif
                              if len(type) ==# 0 | let type = 'html' | endif
                              return type
                            endfunction
                            
    1              0.000002 function! emmet#getDollarExprs(expand) abort
                              let expand = a:expand
                              let dollar_list = []
                              let dollar_reg = '\%(\\\)\@<!\${\(\([^{}]\|\%(\\\)\@\<=[{}]\)\{}\)}'
                              while 1
                                let matcharr = matchlist(expand, dollar_reg)
                                if len(matcharr) > 0
                                  let key = get(matcharr, 1)
                                  if key !~# '^\d\+:'
                                    let key = substitute(key, '\\{', '{', 'g')
                                    let key = substitute(key, '\\}', '}', 'g')
                                    let value = emmet#getDollarValueByKey(key)
                                    if type(value) ==# type('')
                                      let expr = get(matcharr, 0)
                                      call add(dollar_list, {'expr': expr, 'value': value})
                                    endif
                                  endif
                                else
                                  break
                                endif
                                let expand = substitute(expand, dollar_reg, '', '')
                              endwhile
                              return dollar_list
                            endfunction
                            
    1              0.000002 function! emmet#getDollarValueByKey(key) abort
                              let ret = 0
                              let key = a:key
                              let ftsetting = get(s:emmet_settings, emmet#getFileType())
                              if type(ftsetting) ==# 4 && has_key(ftsetting, key)
                                let V = get(ftsetting, key)
                                if type(V) ==# 1 | return V | endif
                              endif
                              if type(ret) !=# 1 && has_key(s:emmet_settings.variables, key)
                                let V = get(s:emmet_settings.variables, key)
                                if type(V) ==# 1 | return V | endif
                              endif
                              if has_key(s:emmet_settings, 'custom_expands') && type(s:emmet_settings['custom_expands']) ==# 4
                                for k in keys(s:emmet_settings['custom_expands'])
                                  if key =~# k
                                    let V = get(s:emmet_settings['custom_expands'], k)
                                    if type(V) ==# 1 | return V | endif
                                    if type(V) ==# 2 | return V(key) | endif
                                  endif
                                endfor
                              endif
                              return ret
                            endfunction
                            
    1              0.000002 function! emmet#reExpandDollarExpr(expand, times) abort
                              let expand = a:expand
                              let dollar_exprs = emmet#getDollarExprs(expand)
                              if len(dollar_exprs) > 0
                                if a:times < 9
                                  for n in range(len(dollar_exprs))
                                    let pair = get(dollar_exprs, n)
                                    let pat = get(pair, 'expr')
                                    let sub = get(pair, 'value')
                                    let expand = substitute(expand, pat, sub, '')
                                  endfor
                                  return emmet#reExpandDollarExpr(expand, a:times + 1)
                                endif
                              endif
                              return expand
                            endfunction
                            
    1              0.000002 function! emmet#expandDollarExpr(expand) abort
                              return emmet#reExpandDollarExpr(a:expand, 0)
                            endfunction
                            
    1              0.000002 function! emmet#expandCursorExpr(expand, mode) abort
                              let expand = a:expand
                              if expand !~# '\${cursor}'
                                if a:mode ==# 2
                                  let expand = '${cursor}' . expand
                                else
                                  let expand .= '${cursor}'
                                endif
                              endif
                              let expand = substitute(expand, '\${\d\+:\?\([^}]\+\)}', '$select$$cursor$\1$select$', 'g')
                              let expand = substitute(expand, '\${\d\+}', '$select$$cursor$$select$', 'g')
                              let expand = substitute(expand, '\${cursor}', '$cursor$', '')
                              let expand = substitute(expand, '\${cursor}', '', 'g')
                              let expand = substitute(expand, '\${cursor}', '', 'g')
                              return expand
                            endfunction
                            
    1              0.000002 function! emmet#unescapeDollarExpr(expand) abort
                              return substitute(a:expand, '\\\$', '$', 'g')
                            endfunction
                            
    1              0.000002 function! emmet#expandAbbr(mode, abbr) range abort
                              let type = emmet#getFileType()
                              let rtype = emmet#lang#type(emmet#getFileType(1))
                              let indent = emmet#getIndentation(type)
                              let expand = ''
                              let line = ''
                              let part = ''
                              let rest = ''
                            
                              let filters = emmet#getFilters(type)
                              if len(filters) ==# 0
                                let filters = ['html']
                              endif
                            
                              if a:mode ==# 2
                                let leader = substitute(input('Tag: ', ''), '^\s*\(.*\)\s*$', '\1', 'g')
                                if len(leader) ==# 0
                                  return ''
                                endif
                                if leader =~# s:filtermx
                                  let filters = map(split(matchstr(leader, s:filtermx)[1:], '\s*[^\\]\zs,\s*'), 'substitute(v:val, "\\\\\\\\zs.\\\\ze", "&", "g")')
                                  let leader = substitute(leader, s:filtermx, '', '')
                                endif
                                if leader =~# '\*'
                                  let query = substitute(leader, '*', '*' . (a:lastline - a:firstline + 1), '')
                                  if query !~# '}\s*$' && query !~# '\$#'
                                    let query .= '>{$#}'
                                  endif
                                  if emmet#useFilter(filters, '/')
                                    let spl = emmet#splitFilterArg(filters)
                                    let fline = getline(a:firstline)
                                    let query = substitute(query, '>\{0,1}{\$#}\s*$', '{\\$column\\$}*' . len(split(fline, spl)), '')
                                  else
                                    let spl = ''
                                  endif
                                  let items = emmet#parseIntoTree(query, type).child
                                  let itemno = 0
                                  for item in items
                                    let inner = emmet#toString(item, type, 0, filters, 0, indent)
                                    let inner = substitute(inner, '\$#', '$line'.(itemno*(a:lastline - a:firstline + 1)/len(items)+1).'$', 'g')
                                    let expand .= inner
                                    let itemno = itemno + 1
                                  endfor
                                  if emmet#useFilter(filters, 'e')
                                    let expand = substitute(expand, '&', '\&amp;', 'g')
                                    let expand = substitute(expand, '<', '\&lt;', 'g')
                                    let expand = substitute(expand, '>', '\&gt;', 'g')
                                  endif
                                  let line = getline(a:firstline)
                                  let part = substitute(line, '^\s*', '', '')
                                  for n in range(a:firstline, a:lastline)
                                    let lline = getline(n)
                                    let lpart = substitute(lline, '^\s\+', '', '')
                                    if emmet#useFilter(filters, 't')
                                      let lpart = substitute(lpart, '^[0-9.-]\+\s\+', '', '')
                                      let lpart = substitute(lpart, '\s\+$', '', '')
                                    endif
                                    if emmet#useFilter(filters, '/')
                                      for column in split(lpart, spl)
                                        let expand = substitute(expand, '\$column\$', '\=column', '')
                                      endfor
                                    else
                                      let expand = substitute(expand, '\$line'.(n-a:firstline+1).'\$', '\=lpart', 'g')
                                    endif
                                  endfor
                                  let expand = substitute(expand, '\$line\d*\$', '', 'g')
                                  let expand = substitute(expand, '\$column\$', '', 'g')
                                  let content = join(getline(a:firstline, a:lastline), "\n")
                                  if stridx(expand, '$#') < len(expand)-2
                                    let expand = substitute(expand, '^\(.*\)\$#\s*$', '\1', '')
                                  endif
                                  let expand = substitute(expand, '\$#', '\=content', 'g')
                                else
                                  let str = ''
                                  if visualmode() ==# 'V'
                                    let line = getline(a:firstline)
                                    let lspaces = matchstr(line, '^\s*', '', '')
                                    let part = substitute(line, '^\s*', '', '')
                                    for n in range(a:firstline, a:lastline)
                                      if len(leader) > 0
                                        let line = getline(a:firstline)
                                        let spaces = matchstr(line, '^\s*', '', '')
                                        if len(spaces) >= len(lspaces)
                                          let str .= indent . getline(n)[len(lspaces):] . "\n"
                                        else
                                          let str .= getline(n) . "\n"
                                        endif
                                      else
                                        let lpart = substitute(getline(n), '^\s*', '', '')
                                        let str .= lpart . "\n"
                                      endif
                                    endfor
                                    if stridx(leader, '{$#}') ==# -1
                                      let leader .= '{$#}'
                                    endif
                                    let items = emmet#parseIntoTree(leader, type).child
                                  else
                                    let save_regcont = @"
                                    let save_regtype = getregtype('"')
                                    silent! normal! gvygv
                                    let str = @"
                                    call setreg('"', save_regcont, save_regtype)
                                    if stridx(leader, '{$#}') ==# -1
                                      let leader .= '{$#}'
                                    endif
                                    let items = emmet#parseIntoTree(leader, type).child
                                  endif
                                  for item in items
                                    let expand .= emmet#toString(item, type, 0, filters, 0, '')
                                  endfor
                                  if emmet#useFilter(filters, 'e')
                                    let expand = substitute(expand, '&', '\&amp;', 'g')
                                    let expand = substitute(expand, '<', '\&lt;', 'g')
                                    let expand = substitute(expand, '>', '\&gt;', 'g')
                                  endif
                                  if stridx(leader, '{$#}') !=# -1
                                    let expand = substitute(expand, '\$#', '\="\n" . str', 'g')
                                  endif
                                endif
                              elseif a:mode ==# 4
                                let line = getline('.')
                                let spaces = matchstr(line, '^\s*')
                                if line !~# '^\s*$'
                                  put =spaces.a:abbr
                                else
                                  call setline('.', spaces.a:abbr)
                                endif
                                normal! $
                                call emmet#expandAbbr(0, '')
                                return ''
                              else
                                let line = getline('.')
                                if col('.') < len(line)
                                  let line = matchstr(line, '^\(.*\%'.col('.').'c\)')
                                endif
                                if a:mode ==# 1
                                  let part = matchstr(line, '\([a-zA-Z0-9:_\-\@|]\+\)$')
                                else
                                  let part = matchstr(line, '\(\S.*\)$')
                                  let ftype = emmet#lang#exists(type) ? type : 'html'
                                  let part = emmet#lang#{ftype}#findTokens(part)
                                  let line = line[0: strridx(line, part) + len(part) - 1]
                                endif
                                if col('.') ==# col('$')
                                  let rest = ''
                                else
                                  let rest = getline('.')[len(line):]
                                endif
                                let str = part
                                if str =~# s:filtermx
                                  let filters = split(matchstr(str, s:filtermx)[1:], '\s*,\s*')
                                  let str = substitute(str, s:filtermx, '', '')
                                endif
                                let items = emmet#parseIntoTree(str, type).child
                                for item in items
                                  let expand .= emmet#toString(item, type, 0, filters, 0, indent)
                                endfor
                                if emmet#useFilter(filters, 'e')
                                  let expand = substitute(expand, '&', '\&amp;', 'g')
                                  let expand = substitute(expand, '<', '\&lt;', 'g')
                                  let expand = substitute(expand, '>', '\&gt;', 'g')
                                endif
                                let expand = substitute(expand, '\$line\([0-9]\+\)\$', '\=submatch(1)', 'g')
                              endif
                              let expand = emmet#expandDollarExpr(expand)
                              let expand = emmet#expandCursorExpr(expand, a:mode)
                              if len(expand)
                                if has_key(s:emmet_settings, 'timezone') && len(s:emmet_settings.timezone)
                                  let expand = substitute(expand, '${datetime}', strftime('%Y-%m-%dT%H:%M:%S') . s:emmet_settings.timezone, 'g')
                                else
                                  " TODO: on windows, %z/%Z is 'Tokyo(Standard)'
                                  let expand = substitute(expand, '${datetime}', strftime('%Y-%m-%dT%H:%M:%S %z'), 'g')
                                endif
                                let expand = emmet#unescapeDollarExpr(expand)
                                if a:mode ==# 2 && visualmode() ==# 'v'
                                  if a:firstline ==# a:lastline
                                    let expand = substitute(expand, '[\r\n]\s*', '', 'g')
                                  else
                                    let expand = substitute(expand, '[\n]$', '', 'g')
                                  endif
                                  silent! normal! gv
                                  let col = col('''<')
                                  silent! normal! c
                                  let line = getline('.')
                                  let lhs = matchstr(line, '.*\%<'.col.'c.')
                                  let rhs = matchstr(line, '\%>'.(col-1).'c.*')
                                  let expand = lhs.expand.rhs
                                  let lines = split(expand, '\n')
                                  call setline(line('.'), lines[0])
                                  if len(lines) > 1
                                    call append(line('.'), lines[1:])
                                  endif
                                else
                                  if line[:-len(part)-1] =~# '^\s\+$'
                                    let indent = line[:-len(part)-1]
                                  else
                                    let indent = ''
                                  endif
                                  let expand = substitute(expand, '[\r\n]\s*$', '', 'g')
                                  if emmet#useFilter(filters, 's')
                                    let epart = substitute(expand, '[\r\n]\s*', '', 'g')
                                  else
                                    let epart = substitute(expand, '[\r\n]', "\n" . indent, 'g')
                                  endif
                                  let expand = line[:-len(part)-1] . epart . rest
                                  let lines = split(expand, '[\r\n]', 1)
                                  if a:mode ==# 2
                                    silent! exe 'normal! gvc'
                                  endif
                                  call setline('.', lines[0])
                                  if len(lines) > 1
                                    call append('.', lines[1:])
                                  endif
                                endif
                              endif
                              if g:emmet_debug > 1
                                call getchar()
                              endif
                              if search('\ze\$\(cursor\|select\)\$', 'c')
                                let oldselection = &selection
                                let &selection = 'inclusive'
                                if foldclosed(line('.')) !=# -1
                                  silent! foldopen
                                endif
                                let pos = emmet#util#getcurpos()
                                let use_selection = emmet#getResource(type, 'use_selection', 0)
                                try
                                  let l:gdefault = &gdefault
                                  let &gdefault = 0
                                  if use_selection && getline('.')[col('.')-1:] =~# '^\$select'
                                    let pos[2] += 1
                                    silent! s/\$select\$//
                                    let next = searchpos('.\ze\$select\$', 'nW')
                                    silent! %s/\$\(cursor\|select\)\$//g
                                    call emmet#util#selectRegion([pos[1:2], next])
                                    return "\<esc>gv"
                                  else
                                    silent! %s/\$\(cursor\|select\)\$//g
                                    silent! call setpos('.', pos)
                                    if col('.') < col('$')
                                      return "\<right>"
                                    endif
                                  endif
                                finally
                                  let &gdefault = l:gdefault
                                endtry
                                let &selection = oldselection
                              endif
                              return ''
                            endfunction
                            
    1              0.000002 function! emmet#updateTag() abort
                              let type = emmet#getFileType()
                              let region = emmet#util#searchRegion('<\S', '>')
                              if !emmet#util#regionIsValid(region) || !emmet#util#cursorInRegion(region)
                                return ''
                              endif
                              let content = emmet#util#getContent(region)
                              let content = matchstr(content,  '^<[^><]\+>')
                              if content !~# '^<[^><]\+>$'
                                return ''
                              endif
                              let current = emmet#lang#html#parseTag(content)
                              if empty(current)
                                return ''
                              endif
                            
                              let str = substitute(input('Enter Abbreviation: ', ''), '^\s*\(.*\)\s*$', '\1', 'g')
                              let item = emmet#parseIntoTree(str, type).child[0]
                              for k in keys(item.attr)
                                let current.attr[k] = item.attr[k]
                              endfor
                              let html = substitute(emmet#toString(current, 'html', 1), '\n', '', '')
                              let html = substitute(html, '\${cursor}', '', '')
                              let html = matchstr(html,  '^<[^><]\+>')
                              call emmet#util#setContent(region, html)
                              return ''
                            endfunction
                            
    1              0.000002 function! emmet#moveNextPrevItem(flag) abort
                              let type = emmet#getFileType()
                              return emmet#lang#{emmet#lang#type(type)}#moveNextPrevItem(a:flag)
                            endfunction
                            
    1              0.000001 function! emmet#moveNextPrev(flag) abort
                              let type = emmet#getFileType()
                              return emmet#lang#{emmet#lang#type(type)}#moveNextPrev(a:flag)
                            endfunction
                            
    1              0.000001 function! emmet#imageSize() abort
                              let orgpos = emmet#util#getcurpos()
                              let type = emmet#getFileType()
                              call emmet#lang#{emmet#lang#type(type)}#imageSize()
                              silent! call setpos('.', orgpos)
                              return ''
                            endfunction
                            
    1              0.000001 function! emmet#encodeImage() abort
                              let type = emmet#getFileType()
                              return emmet#lang#{emmet#lang#type(type)}#encodeImage()
                            endfunction
                            
    1              0.000002 function! emmet#toggleComment() abort
                              let type = emmet#getFileType()
                              call emmet#lang#{emmet#lang#type(type)}#toggleComment()
                              return ''
                            endfunction
                            
    1              0.000001 function! emmet#balanceTag(flag) range abort
                              let type = emmet#getFileType()
                              return emmet#lang#{emmet#lang#type(type)}#balanceTag(a:flag)
                            endfunction
                            
    1              0.000001 function! emmet#splitJoinTag() abort
                              let type = emmet#getFileType()
                              return emmet#lang#{emmet#lang#type(type)}#splitJoinTag()
                            endfunction
                            
    1              0.000002 function! emmet#mergeLines() range abort
                              let lines = join(map(getline(a:firstline, a:lastline), 'matchstr(v:val, "^\\s*\\zs.*\\ze\\s*$")'), '')
                              let indent = substitute(getline('.'), '^\(\s*\).*', '\1', '')
                              silent! exe 'normal! gvc'
                              call setline('.', indent . lines)
                            endfunction
                            
    1              0.000002 function! emmet#removeTag() abort
                              let type = emmet#getFileType()
                              call emmet#lang#{emmet#lang#type(type)}#removeTag()
                              return ''
                            endfunction
                            
    1              0.000002 function! emmet#anchorizeURL(flag) abort
                              let mx = 'https\=:\/\/[-!#$%&*+,./:;=?@0-9a-zA-Z_~]\+'
                              let pos1 = searchpos(mx, 'bcnW')
                              let url = matchstr(getline(pos1[0])[pos1[1]-1:], mx)
                              let block = [pos1, [pos1[0], pos1[1] + len(url) - 1]]
                              if !emmet#util#cursorInRegion(block)
                                return ''
                              endif
                            
                              let mx = '.*<title[^>]*>\s*\zs\([^<]\+\)\ze\s*<\/title[^>]*>.*'
                              let content = emmet#util#getContentFromURL(url)
                              let content = substitute(content, '\r', '', 'g')
                              let content = substitute(content, '[ \n]\+', ' ', 'g')
                              let content = substitute(content, '<!--.\{-}-->', '', 'g')
                              let title = matchstr(content, mx)
                            
                              let type = emmet#getFileType()
                              let rtype = emmet#lang#type(type)
                              if &filetype ==# 'markdown'
                                let expand = printf('[%s](%s)', substitute(title, '[\[\]]', '\\&', 'g'), url)
                              elseif a:flag ==# 0
                                let a = emmet#lang#html#parseTag('<a>')
                                let a.attr.href = url
                                let a.value = '{' . title . '}'
                                let expand = emmet#toString(a, rtype, 0, [])
                                let expand = substitute(expand, '\${cursor}', '', 'g')
                              else
                                let body = emmet#util#getTextFromHTML(content)
                                let body = '{' . substitute(body, '^\(.\{0,100}\).*', '\1', '') . '...}'
                            
                                let blockquote = emmet#lang#html#parseTag('<blockquote class="quote">')
                                let a = emmet#lang#html#parseTag('<a>')
                                let a.attr.href = url
                                let a.value = '{' . title . '}'
                                call add(blockquote.child, a)
                                call add(blockquote.child, emmet#lang#html#parseTag('<br/>'))
                                let p = emmet#lang#html#parseTag('<p>')
                                let p.value = body
                                call add(blockquote.child, p)
                                let cite = emmet#lang#html#parseTag('<cite>')
                                let cite.value = '{' . url . '}'
                                call add(blockquote.child, cite)
                                let expand = emmet#toString(blockquote, rtype, 0, [])
                                let expand = substitute(expand, '\${cursor}', '', 'g')
                              endif
                              let indent = substitute(getline('.'), '^\(\s*\).*', '\1', '')
                              let expand = substitute(expand, "\n", "\n" . indent, 'g')
                              call emmet#util#setContent(block, expand)
                              return ''
                            endfunction
                            
    1              0.000002 function! emmet#codePretty() range abort
                              let type = input('FileType: ', &filetype, 'filetype')
                              if len(type) ==# 0
                                return
                              endif
                              let block = emmet#util#getVisualBlock()
                              let content = emmet#util#getContent(block)
                              silent! 1new
                              let &l:filetype = type
                              call setline(1, split(content, "\n"))
                              let old_lazyredraw = &lazyredraw
                              set lazyredraw
                              silent! TOhtml
                              let &lazyredraw = old_lazyredraw
                              let content = join(getline(1, '$'), "\n")
                              silent! bw!
                              silent! bw!
                              let content = matchstr(content, '<body[^>]*>[\s\n]*\zs.*\ze</body>')
                              call emmet#util#setContent(block, content)
                            endfunction
                            
    1              0.000002 function! emmet#expandWord(abbr, type, orig) abort
                              let str = a:abbr
                              let type = a:type
                              let indent = emmet#getIndentation(type)
                            
                              if len(type) ==# 0 | let type = 'html' | endif
                              if str =~# s:filtermx
                                let filters = split(matchstr(str, s:filtermx)[1:], '\s*,\s*')
                                let str = substitute(str, s:filtermx, '', '')
                              else
                                let filters = emmet#getFilters(a:type)
                                if len(filters) ==# 0
                                  let filters = ['html']
                                endif
                              endif
                              let str = substitute(str, '|', '${cursor}', 'g')
                              let items = emmet#parseIntoTree(str, a:type).child
                              let expand = ''
                              for item in items
                                let expand .= emmet#toString(item, a:type, 0, filters, 0, indent)
                              endfor
                              if emmet#useFilter(filters, 'e')
                                let expand = substitute(expand, '&', '\&amp;', 'g')
                                let expand = substitute(expand, '<', '\&lt;', 'g')
                                let expand = substitute(expand, '>', '\&gt;', 'g')
                              endif
                              if emmet#useFilter(filters, 's')
                                let expand = substitute(expand, "\n\s\*", '', 'g')
                              endif
                              if a:orig ==# 0
                                let expand = emmet#expandDollarExpr(expand)
                                let expand = substitute(expand, '\${cursor}', '', 'g')
                              endif
                              return expand
                            endfunction
                            
    1              0.000001 function! emmet#getSnippets(type) abort
                              let type = a:type
                              if len(type) ==# 0 || !has_key(s:emmet_settings, type)
                                let type = 'html'
                              endif
                              return emmet#getResource(type, 'snippets', {})
                            endfunction
                            
    1              0.000002 function! emmet#completeTag(findstart, base) abort
                              if a:findstart
                                let line = getline('.')
                                let start = col('.') - 1
                                while start > 0 && line[start - 1] =~# '[a-zA-Z0-9:_\@\-]'
                                  let start -= 1
                                endwhile
                                return start
                              else
                                let type = emmet#getFileType()
                                let res = []
                            
                                let snippets = emmet#getResource(type, 'snippets', {})
                                for item in keys(snippets)
                                  if stridx(item, a:base) !=# -1
                                    call add(res, substitute(item, '\${cursor}\||', '', 'g'))
                                  endif
                                endfor
                                let aliases = emmet#getResource(type, 'aliases', {})
                                for item in values(aliases)
                                  if stridx(item, a:base) !=# -1
                                    call add(res, substitute(item, '\${cursor}\||', '', 'g'))
                                  endif
                                endfor
                                return res
                              endif
                            endfunction
                            
    1              0.000003 unlet! s:emmet_settings
    1              0.001251 let s:emmet_settings = {
                            \    'variables': {
                            \      'lang': "en",
                            \      'locale': "en-US",
                            \      'charset': "UTF-8",
                            \      'newline': "\n",
                            \      'use_selection': 0,
                            \    },
                            \    'custom_expands' : {
                            \      '^\%(lorem\|lipsum\)\(\d*\)$' : function('emmet#lorem#en#expand'),
                            \    },
                            \    'css': {
                            \        'snippets': {
                            \           "@i": "@import url(|);",
                            \           "@import": "@import url(|);",
                            \           "@m": "@media ${1:screen} {\n\t|\n}",
                            \           "@media": "@media ${1:screen} {\n\t|\n}",
                            \           "@f": "@font-face {\n\tfont-family:|;\n\tsrc:url(|);\n}",
                            \           "@f+": "@font-face {\n\tfont-family: '${1:FontName}';\n\tsrc: url('${2:FileName}.eot');\n\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\n\t\t url('${2:FileName}.woff') format('woff'),\n\t\t url('${2:FileName}.ttf') format('truetype'),\n\t\t url('${2:FileName}.svg#${1:FontName}') format('svg');\n\tfont-style: ${3:normal};\n\tfont-weight: ${4:normal};\n}",
                            \           "@kf": "@-webkit-keyframes ${1:identifier} {\n\t${2:from} { ${3} }${6}\n\t${4:to} { ${5} }\n}\n@-o-keyframes ${1:identifier} {\n\t${2:from} { ${3} }${6}\n\t${4:to} { ${5} }\n}\n@-moz-keyframes ${1:identifier} {\n\t${2:from} { ${3} }${6}\n\t${4:to} { ${5} }\n}\n@keyframes ${1:identifier} {\n\t${2:from} { ${3} }${6}\n\t${4:to} { ${5} }\n}",
                            \           "anim": "animation:|;",
                            \           "anim-": "animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode};",
                            \           "animdel": "animation-delay:${1:time};",
                            \           "animdir": "animation-direction:${1:normal};",
                            \           "animdir:n": "animation-direction:normal;",
                            \           "animdir:r": "animation-direction:reverse;",
                            \           "animdir:a": "animation-direction:alternate;",
                            \           "animdir:ar": "animation-direction:alternate-reverse;",
                            \           "animdur": "animation-duration:${1:0}s;",
                            \           "animfm": "animation-fill-mode:${1:both};",
                            \           "animfm:f": "animation-fill-mode:forwards;",
                            \           "animfm:b": "animation-fill-mode:backwards;",
                            \           "animfm:bt": "animation-fill-mode:both;",
                            \           "animfm:bh": "animation-fill-mode:both;",
                            \           "animic": "animation-iteration-count:${1:1};",
                            \           "animic:i": "animation-iteration-count:infinite;",
                            \           "animn": "animation-name:${1:none};",
                            \           "animps": "animation-play-state:${1:running};",
                            \           "animps:p": "animation-play-state:paused;",
                            \           "animps:r": "animation-play-state:running;",
                            \           "animtf": "animation-timing-function:${1:linear};",
                            \           "animtf:e": "animation-timing-function:ease;",
                            \           "animtf:ei": "animation-timing-function:ease-in;",
                            \           "animtf:eo": "animation-timing-function:ease-out;",
                            \           "animtf:eio": "animation-timing-function:ease-in-out;",
                            \           "animtf:l": "animation-timing-function:linear;",
                            \           "animtf:cb": "animation-timing-function:cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1});",
                            \           "ap": "appearance:${none};",
                            \           "!": "!important",
                            \           "pos": "position:${1:relative};",
                            \           "pos:s": "position:static;",
                            \           "pos:a": "position:absolute;",
                            \           "pos:r": "position:relative;",
                            \           "pos:f": "position:fixed;",
                            \           "t": "top:|;",
                            \           "t:a": "top:auto;",
                            \           "r": "right:|;",
                            \           "r:a": "right:auto;",
                            \           "b": "bottom:|;",
                            \           "b:a": "bottom:auto;",
                            \           "l": "left:|;",
                            \           "l:a": "left:auto;",
                            \           "z": "z-index:|;",
                            \           "z:a": "z-index:auto;",
                            \           "fl": "float:${1:left};",
                            \           "fl:n": "float:none;",
                            \           "fl:l": "float:left;",
                            \           "fl:r": "float:right;",
                            \           "cl": "clear:${1:both};",
                            \           "cl:n": "clear:none;",
                            \           "cl:l": "clear:left;",
                            \           "cl:r": "clear:right;",
                            \           "cl:b": "clear:both;",
                            \           "colm": "columns:|;",
                            \           "colmc": "column-count:|;",
                            \           "colmf": "column-fill:|;",
                            \           "colmg": "column-gap:|;",
                            \           "colmr": "column-rule:|;",
                            \           "colmrc": "column-rule-color:|;",
                            \           "colmrs": "column-rule-style:|;",
                            \           "colmrw": "column-rule-width:|;",
                            \           "colms": "column-span:|;",
                            \           "colmw": "column-width:|;",
                            \           "d": "display:${1:block};",
                            \           "d:n": "display:none;",
                            \           "d:b": "display:block;",
                            \           "d:f": "display:flex;",
                            \           "d:if": "display:inline-flex;",
                            \           "d:i": "display:inline;",
                            \           "d:ib": "display:inline-block;",
                            \           "d:ib+": "display: inline-block;\n*display: inline;\n*zoom: 1;",
                            \           "d:li": "display:list-item;",
                            \           "d:ri": "display:run-in;",
                            \           "d:cp": "display:compact;",
                            \           "d:tb": "display:table;",
                            \           "d:itb": "display:inline-table;",
                            \           "d:tbcp": "display:table-caption;",
                            \           "d:tbcl": "display:table-column;",
                            \           "d:tbclg": "display:table-column-group;",
                            \           "d:tbhg": "display:table-header-group;",
                            \           "d:tbfg": "display:table-footer-group;",
                            \           "d:tbr": "display:table-row;",
                            \           "d:tbrg": "display:table-row-group;",
                            \           "d:tbc": "display:table-cell;",
                            \           "d:rb": "display:ruby;",
                            \           "d:rbb": "display:ruby-base;",
                            \           "d:rbbg": "display:ruby-base-group;",
                            \           "d:rbt": "display:ruby-text;",
                            \           "d:rbtg": "display:ruby-text-group;",
                            \           "v": "visibility:${1:hidden};",
                            \           "v:v": "visibility:visible;",
                            \           "v:h": "visibility:hidden;",
                            \           "v:c": "visibility:collapse;",
                            \           "ov": "overflow:${1:hidden};",
                            \           "ov:v": "overflow:visible;",
                            \           "ov:h": "overflow:hidden;",
                            \           "ov:s": "overflow:scroll;",
                            \           "ov:a": "overflow:auto;",
                            \           "ovx": "overflow-x:${1:hidden};",
                            \           "ovx:v": "overflow-x:visible;",
                            \           "ovx:h": "overflow-x:hidden;",
                            \           "ovx:s": "overflow-x:scroll;",
                            \           "ovx:a": "overflow-x:auto;",
                            \           "ovy": "overflow-y:${1:hidden};",
                            \           "ovy:v": "overflow-y:visible;",
                            \           "ovy:h": "overflow-y:hidden;",
                            \           "ovy:s": "overflow-y:scroll;",
                            \           "ovy:a": "overflow-y:auto;",
                            \           "ovs": "overflow-style:${1:scrollbar};",
                            \           "ovs:a": "overflow-style:auto;",
                            \           "ovs:s": "overflow-style:scrollbar;",
                            \           "ovs:p": "overflow-style:panner;",
                            \           "ovs:m": "overflow-style:move;",
                            \           "ovs:mq": "overflow-style:marquee;",
                            \           "zoo": "zoom:1;",
                            \           "zm": "zoom:1;",
                            \           "cp": "clip:|;",
                            \           "cp:a": "clip:auto;",
                            \           "cp:r": "clip:rect(${1:top} ${2:right} ${3:bottom} ${4:left});",
                            \           "bxz": "box-sizing:${1:border-box};",
                            \           "bxz:cb": "box-sizing:content-box;",
                            \           "bxz:bb": "box-sizing:border-box;",
                            \           "bxsh": "box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:color};",
                            \           "bxsh:r": "box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:spread }rgb(${6:0}, ${7:0}, ${8:0});",
                            \           "bxsh:ra": "box-shadow:${1:inset }${2:h} ${3:v} ${4:blur} ${5:spread }rgba(${6:0}, ${7:0}, ${8:0}, .${9:5});",
                            \           "bxsh:n": "box-shadow:none;",
                            \           "m": "margin:|;",
                            \           "m:a": "margin:auto;",
                            \           "mt": "margin-top:|;",
                            \           "mt:a": "margin-top:auto;",
                            \           "mr": "margin-right:|;",
                            \           "mr:a": "margin-right:auto;",
                            \           "mb": "margin-bottom:|;",
                            \           "mb:a": "margin-bottom:auto;",
                            \           "ml": "margin-left:|;",
                            \           "ml:a": "margin-left:auto;",
                            \           "p": "padding:|;",
                            \           "pt": "padding-top:|;",
                            \           "pr": "padding-right:|;",
                            \           "pb": "padding-bottom:|;",
                            \           "pl": "padding-left:|;",
                            \           "w": "width:|;",
                            \           "w:a": "width:auto;",
                            \           "h": "height:|;",
                            \           "h:a": "height:auto;",
                            \           "maw": "max-width:|;",
                            \           "maw:n": "max-width:none;",
                            \           "mah": "max-height:|;",
                            \           "mah:n": "max-height:none;",
                            \           "miw": "min-width:|;",
                            \           "mih": "min-height:|;",
                            \           "mar": "max-resolution:${1:res};",
                            \           "mir": "min-resolution:${1:res};",
                            \           "ori": "orientation:|;",
                            \           "ori:l": "orientation:landscape;",
                            \           "ori:p": "orientation:portrait;",
                            \           "ol": "outline:|;",
                            \           "ol:n": "outline:none;",
                            \           "olo": "outline-offset:|;",
                            \           "olw": "outline-width:|;",
                            \           "olw:tn": "outline-width:thin;",
                            \           "olw:m": "outline-width:medium;",
                            \           "olw:tc": "outline-width:thick;",
                            \           "ols": "outline-style:|;",
                            \           "ols:n": "outline-style:none;",
                            \           "ols:dt": "outline-style:dotted;",
                            \           "ols:ds": "outline-style:dashed;",
                            \           "ols:s": "outline-style:solid;",
                            \           "ols:db": "outline-style:double;",
                            \           "ols:g": "outline-style:groove;",
                            \           "ols:r": "outline-style:ridge;",
                            \           "ols:i": "outline-style:inset;",
                            \           "ols:o": "outline-style:outset;",
                            \           "olc": "outline-color:#${1:000};",
                            \           "olc:i": "outline-color:invert;",
                            \           "bfv": "backface-visibility:|;",
                            \           "bfv:h": "backface-visibility:hidden;",
                            \           "bfv:v": "backface-visibility:visible;",
                            \           "bd": "border:|;",
                            \           "bd+": "border:${1:1px} ${2:solid} ${3:#000};",
                            \           "bd:n": "border:none;",
                            \           "bdbk": "border-break:${1:close};",
                            \           "bdbk:c": "border-break:close;",
                            \           "bdcl": "border-collapse:|;",
                            \           "bdcl:c": "border-collapse:collapse;",
                            \           "bdcl:s": "border-collapse:separate;",
                            \           "bdc": "border-color:#${1:000};",
                            \           "bdc:t": "border-color:transparent;",
                            \           "bdi": "border-image:url(|);",
                            \           "bdi:n": "border-image:none;",
                            \           "bdti": "border-top-image:url(|);",
                            \           "bdti:n": "border-top-image:none;",
                            \           "bdri": "border-right-image:url(|);",
                            \           "bdri:n": "border-right-image:none;",
                            \           "bdbi": "border-bottom-image:url(|);",
                            \           "bdbi:n": "border-bottom-image:none;",
                            \           "bdli": "border-left-image:url(|);",
                            \           "bdli:n": "border-left-image:none;",
                            \           "bdci": "border-corner-image:url(|);",
                            \           "bdci:n": "border-corner-image:none;",
                            \           "bdci:c": "border-corner-image:continue;",
                            \           "bdtli": "border-top-left-image:url(|);",
                            \           "bdtli:n": "border-top-left-image:none;",
                            \           "bdtli:c": "border-top-left-image:continue;",
                            \           "bdtri": "border-top-right-image:url(|);",
                            \           "bdtri:n": "border-top-right-image:none;",
                            \           "bdtri:c": "border-top-right-image:continue;",
                            \           "bdbri": "border-bottom-right-image:url(|);",
                            \           "bdbri:n": "border-bottom-right-image:none;",
                            \           "bdbri:c": "border-bottom-right-image:continue;",
                            \           "bdbli": "border-bottom-left-image:url(|);",
                            \           "bdbli:n": "border-bottom-left-image:none;",
                            \           "bdbli:c": "border-bottom-left-image:continue;",
                            \           "bdf": "border-fit:${1:repeat};",
                            \           "bdf:c": "border-fit:clip;",
                            \           "bdf:r": "border-fit:repeat;",
                            \           "bdf:sc": "border-fit:scale;",
                            \           "bdf:st": "border-fit:stretch;",
                            \           "bdf:ow": "border-fit:overwrite;",
                            \           "bdf:of": "border-fit:overflow;",
                            \           "bdf:sp": "border-fit:space;",
                            \           "bdlen": "border-length:|;",
                            \           "bdlen:a": "border-length:auto;",
                            \           "bdsp": "border-spacing:|;",
                            \           "bds": "border-style:|;",
                            \           "bds:n": "border-style:none;",
                            \           "bds:h": "border-style:hidden;",
                            \           "bds:dt": "border-style:dotted;",
                            \           "bds:ds": "border-style:dashed;",
                            \           "bds:s": "border-style:solid;",
                            \           "bds:db": "border-style:double;",
                            \           "bds:dtds": "border-style:dot-dash;",
                            \           "bds:dtdtds": "border-style:dot-dot-dash;",
                            \           "bds:w": "border-style:wave;",
                            \           "bds:g": "border-style:groove;",
                            \           "bds:r": "border-style:ridge;",
                            \           "bds:i": "border-style:inset;",
                            \           "bds:o": "border-style:outset;",
                            \           "bdw": "border-width:|;",
                            \           "bdtw": "border-top-width:|;",
                            \           "bdrw": "border-right-width:|;",
                            \           "bdbw": "border-bottom-width:|;",
                            \           "bdlw": "border-left-width:|;",
                            \           "bdt": "border-top:|;",
                            \           "bt": "border-top:|;",
                            \           "bdt+": "border-top:${1:1px} ${2:solid} ${3:#000};",
                            \           "bdt:n": "border-top:none;",
                            \           "bdts": "border-top-style:|;",
                            \           "bdts:n": "border-top-style:none;",
                            \           "bdtc": "border-top-color:#${1:000};",
                            \           "bdtc:t": "border-top-color:transparent;",
                            \           "bdr": "border-right:|;",
                            \           "br": "border-right:|;",
                            \           "bdr+": "border-right:${1:1px} ${2:solid} ${3:#000};",
                            \           "bdr:n": "border-right:none;",
                            \           "bdrst": "border-right-style:|;",
                            \           "bdrst:n": "border-right-style:none;",
                            \           "bdrc": "border-right-color:#${1:000};",
                            \           "bdrc:t": "border-right-color:transparent;",
                            \           "bdb": "border-bottom:|;",
                            \           "bb": "border-bottom:|;",
                            \           "bdb+": "border-bottom:${1:1px} ${2:solid} ${3:#000};",
                            \           "bdb:n": "border-bottom:none;",
                            \           "bdbs": "border-bottom-style:|;",
                            \           "bdbs:n": "border-bottom-style:none;",
                            \           "bdbc": "border-bottom-color:#${1:000};",
                            \           "bdbc:t": "border-bottom-color:transparent;",
                            \           "bdl": "border-left:|;",
                            \           "bl": "border-left:|;",
                            \           "bdl+": "border-left:${1:1px} ${2:solid} ${3:#000};",
                            \           "bdl:n": "border-left:none;",
                            \           "bdls": "border-left-style:|;",
                            \           "bdls:n": "border-left-style:none;",
                            \           "bdlc": "border-left-color:#${1:000};",
                            \           "bdlc:t": "border-left-color:transparent;",
                            \           "bdrs": "border-radius:|;",
                            \           "bdtrrs": "border-top-right-radius:|;",
                            \           "bdtlrs": "border-top-left-radius:|;",
                            \           "bdbrrs": "border-bottom-right-radius:|;",
                            \           "bdblrs": "border-bottom-left-radius:|;",
                            \           "bg": "background:#${1:000};",
                            \           "bg+": "background:${1:#fff} url(${2}) ${3:0} ${4:0} ${5:no-repeat};",
                            \           "bg:n": "background:none;",
                            \           "bg:ie": "filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1:x}.png',sizingMethod='${2:crop}');",
                            \           "bgc": "background-color:#${1:fff};",
                            \           "bgc:t": "background-color:transparent;",
                            \           "bgi": "background-image:url(|);",
                            \           "bgi:n": "background-image:none;",
                            \           "bgr": "background-repeat:|;",
                            \           "bgr:n": "background-repeat:no-repeat;",
                            \           "bgr:x": "background-repeat:repeat-x;",
                            \           "bgr:y": "background-repeat:repeat-y;",
                            \           "bgr:sp": "background-repeat:space;",
                            \           "bgr:rd": "background-repeat:round;",
                            \           "bga": "background-attachment:|;",
                            \           "bga:f": "background-attachment:fixed;",
                            \           "bga:s": "background-attachment:scroll;",
                            \           "bgp": "background-position:${1:0} ${2:0};",
                            \           "bgpx": "background-position-x:|;",
                            \           "bgpy": "background-position-y:|;",
                            \           "bgbk": "background-break:|;",
                            \           "bgbk:bb": "background-break:bounding-box;",
                            \           "bgbk:eb": "background-break:each-box;",
                            \           "bgbk:c": "background-break:continuous;",
                            \           "bgcp": "background-clip:${1:padding-box};",
                            \           "bgcp:bb": "background-clip:border-box;",
                            \           "bgcp:pb": "background-clip:padding-box;",
                            \           "bgcp:cb": "background-clip:content-box;",
                            \           "bgcp:nc": "background-clip:no-clip;",
                            \           "bgo": "background-origin:|;",
                            \           "bgo:pb": "background-origin:padding-box;",
                            \           "bgo:bb": "background-origin:border-box;",
                            \           "bgo:cb": "background-origin:content-box;",
                            \           "bgsz": "background-size:|;",
                            \           "bgsz:a": "background-size:auto;",
                            \           "bgsz:ct": "background-size:contain;",
                            \           "bgsz:cv": "background-size:cover;",
                            \           "c": "color:#${1:000};",
                            \           "c:r": "color:rgb(${1:0}, ${2:0}, ${3:0});",
                            \           "c:ra": "color:rgba(${1:0}, ${2:0}, ${3:0}, .${4:5});",
                            \           "cm": "/* |${child} */",
                            \           "cnt": "content:'|';",
                            \           "cnt:n": "content:normal;",
                            \           "cnt:oq": "content:open-quote;",
                            \           "cnt:noq": "content:no-open-quote;",
                            \           "cnt:cq": "content:close-quote;",
                            \           "cnt:ncq": "content:no-close-quote;",
                            \           "cnt:a": "content:attr(|);",
                            \           "cnt:c": "content:counter(|);",
                            \           "cnt:cs": "content:counters(|);",
                            \           "tbl": "table-layout:|;",
                            \           "tbl:a": "table-layout:auto;",
                            \           "tbl:f": "table-layout:fixed;",
                            \           "cps": "caption-side:|;",
                            \           "cps:t": "caption-side:top;",
                            \           "cps:b": "caption-side:bottom;",
                            \           "ec": "empty-cells:|;",
                            \           "ec:s": "empty-cells:show;",
                            \           "ec:h": "empty-cells:hide;",
                            \           "lis": "list-style:|;",
                            \           "lis:n": "list-style:none;",
                            \           "lisp": "list-style-position:|;",
                            \           "lisp:i": "list-style-position:inside;",
                            \           "lisp:o": "list-style-position:outside;",
                            \           "list": "list-style-type:|;",
                            \           "list:n": "list-style-type:none;",
                            \           "list:d": "list-style-type:disc;",
                            \           "list:c": "list-style-type:circle;",
                            \           "list:s": "list-style-type:square;",
                            \           "list:dc": "list-style-type:decimal;",
                            \           "list:dclz": "list-style-type:decimal-leading-zero;",
                            \           "list:lr": "list-style-type:lower-roman;",
                            \           "list:ur": "list-style-type:upper-roman;",
                            \           "lisi": "list-style-image:|;",
                            \           "lisi:n": "list-style-image:none;",
                            \           "q": "quotes:|;",
                            \           "q:n": "quotes:none;",
                            \           "q:ru": "quotes:'\\00AB' '\\00BB' '\\201E' '\\201C';",
                            \           "q:en": "quotes:'\\201C' '\\201D' '\\2018' '\\2019';",
                            \           "ct": "content:|;",
                            \           "ct:n": "content:normal;",
                            \           "ct:oq": "content:open-quote;",
                            \           "ct:noq": "content:no-open-quote;",
                            \           "ct:cq": "content:close-quote;",
                            \           "ct:ncq": "content:no-close-quote;",
                            \           "ct:a": "content:attr(|);",
                            \           "ct:c": "content:counter(|);",
                            \           "ct:cs": "content:counters(|);",
                            \           "coi": "counter-increment:|;",
                            \           "cor": "counter-reset:|;",
                            \           "va": "vertical-align:${1:top};",
                            \           "va:sup": "vertical-align:super;",
                            \           "va:t": "vertical-align:top;",
                            \           "va:tt": "vertical-align:text-top;",
                            \           "va:m": "vertical-align:middle;",
                            \           "va:bl": "vertical-align:baseline;",
                            \           "va:b": "vertical-align:bottom;",
                            \           "va:tb": "vertical-align:text-bottom;",
                            \           "va:sub": "vertical-align:sub;",
                            \           "ta": "text-align:${1:left};",
                            \           "ta:l": "text-align:left;",
                            \           "ta:c": "text-align:center;",
                            \           "ta:r": "text-align:right;",
                            \           "ta:j": "text-align:justify;",
                            \           "ta-lst": "text-align-last:|;",
                            \           "tal:a": "text-align-last:auto;",
                            \           "tal:l": "text-align-last:left;",
                            \           "tal:c": "text-align-last:center;",
                            \           "tal:r": "text-align-last:right;",
                            \           "td": "text-decoration:${1:none};",
                            \           "td:n": "text-decoration:none;",
                            \           "td:u": "text-decoration:underline;",
                            \           "td:o": "text-decoration:overline;",
                            \           "td:l": "text-decoration:line-through;",
                            \           "te": "text-emphasis:|;",
                            \           "te:n": "text-emphasis:none;",
                            \           "te:ac": "text-emphasis:accent;",
                            \           "te:dt": "text-emphasis:dot;",
                            \           "te:c": "text-emphasis:circle;",
                            \           "te:ds": "text-emphasis:disc;",
                            \           "te:b": "text-emphasis:before;",
                            \           "te:a": "text-emphasis:after;",
                            \           "th": "text-height:|;",
                            \           "th:a": "text-height:auto;",
                            \           "th:f": "text-height:font-size;",
                            \           "th:t": "text-height:text-size;",
                            \           "th:m": "text-height:max-size;",
                            \           "ti": "text-indent:|;",
                            \           "ti:-": "text-indent:-9999px;",
                            \           "tj": "text-justify:|;",
                            \           "tj:a": "text-justify:auto;",
                            \           "tj:iw": "text-justify:inter-word;",
                            \           "tj:ii": "text-justify:inter-ideograph;",
                            \           "tj:ic": "text-justify:inter-cluster;",
                            \           "tj:d": "text-justify:distribute;",
                            \           "tj:k": "text-justify:kashida;",
                            \           "tj:t": "text-justify:tibetan;",
                            \           "tov": "text-overflow:${ellipsis};",
                            \           "tov:e": "text-overflow:ellipsis;",
                            \           "tov:c": "text-overflow:clip;",
                            \           "to": "text-outline:|;",
                            \           "to+": "text-outline:${1:0} ${2:0} ${3:#000};",
                            \           "to:n": "text-outline:none;",
                            \           "tr": "text-replace:|;",
                            \           "tr:n": "text-replace:none;",
                            \           "tt": "text-transform:${1:uppercase};",
                            \           "tt:n": "text-transform:none;",
                            \           "tt:c": "text-transform:capitalize;",
                            \           "tt:u": "text-transform:uppercase;",
                            \           "tt:l": "text-transform:lowercase;",
                            \           "tw": "text-wrap:|;",
                            \           "tw:n": "text-wrap:normal;",
                            \           "tw:no": "text-wrap:none;",
                            \           "tw:u": "text-wrap:unrestricted;",
                            \           "tw:s": "text-wrap:suppress;",
                            \           "tsh": "text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000};",
                            \           "tsh:r": "text-shadow:${1:h} ${2:v} ${3:blur} rgb(${4:0}, ${5:0}, ${6:0});",
                            \           "tsh:ra": "text-shadow:${1:h} ${2:v} ${3:blur} rgba(${4:0}, ${5:0}, ${6:0}, .${7:5});",
                            \           "tsh+": "text-shadow:${1:0} ${2:0} ${3:0} ${4:#000};",
                            \           "tsh:n": "text-shadow:none;",
                            \           "trf": "transform:|;",
                            \           "trf:skx": "transform: skewX(${1:angle});",
                            \           "trf:sky": "transform: skewY(${1:angle});",
                            \           "trf:sc": "transform: scale(${1:x}, ${2:y});",
                            \           "trf:scx": "transform: scaleX(${1:x});",
                            \           "trf:scy": "transform: scaleY(${1:y});",
                            \           "trf:scz": "transform: scaleZ(${1:z});",
                            \           "trf:sc3": "transform: scale3d(${1:x}, ${2:y}, ${3:z});",
                            \           "trf:r": "transform: rotate(${1:angle});",
                            \           "trf:rx": "transform: rotateX(${1:angle});",
                            \           "trf:ry": "transform: rotateY(${1:angle});",
                            \           "trf:rz": "transform: rotateZ(${1:angle});",
                            \           "trf:t": "transform: translate(${1:x}, ${2:y});",
                            \           "trf:tx": "transform: translateX(${1:x});",
                            \           "trf:ty": "transform: translateY(${1:y});",
                            \           "trf:tz": "transform: translateZ(${1:z});",
                            \           "trf:t3": "transform: translate3d(${1:tx}, ${2:ty}, ${3:tz});",
                            \           "trfo": "transform-origin:|;",
                            \           "trfs": "transform-style:${1:preserve-3d};",
                            \           "trs": "transition:${1:prop} ${2:time};",
                            \           "trsde": "transition-delay:${1:time};",
                            \           "trsdu": "transition-duration:${1:time};",
                            \           "trsp": "transition-property:${1:prop};",
                            \           "trstf": "transition-timing-function:${1:tfunc};",
                            \           "lh": "line-height:|;",
                            \           "whs": "white-space:|;",
                            \           "whs:n": "white-space:normal;",
                            \           "whs:p": "white-space:pre;",
                            \           "whs:nw": "white-space:nowrap;",
                            \           "whs:pw": "white-space:pre-wrap;",
                            \           "whs:pl": "white-space:pre-line;",
                            \           "whsc": "white-space-collapse:|;",
                            \           "whsc:n": "white-space-collapse:normal;",
                            \           "whsc:k": "white-space-collapse:keep-all;",
                            \           "whsc:l": "white-space-collapse:loose;",
                            \           "whsc:bs": "white-space-collapse:break-strict;",
                            \           "whsc:ba": "white-space-collapse:break-all;",
                            \           "wob": "word-break:|;",
                            \           "wob:n": "word-break:normal;",
                            \           "wob:k": "word-break:keep-all;",
                            \           "wob:ba": "word-break:break-all;",
                            \           "wos": "word-spacing:|;",
                            \           "wow": "word-wrap:|;",
                            \           "wow:nm": "word-wrap:normal;",
                            \           "wow:n": "word-wrap:none;",
                            \           "wow:u": "word-wrap:unrestricted;",
                            \           "wow:s": "word-wrap:suppress;",
                            \           "wow:b": "word-wrap:break-word;",
                            \           "wm": "writing-mode:${1:lr-tb};",
                            \           "wm:lrt": "writing-mode:lr-tb;",
                            \           "wm:lrb": "writing-mode:lr-bt;",
                            \           "wm:rlt": "writing-mode:rl-tb;",
                            \           "wm:rlb": "writing-mode:rl-bt;",
                            \           "wm:tbr": "writing-mode:tb-rl;",
                            \           "wm:tbl": "writing-mode:tb-lr;",
                            \           "wm:btl": "writing-mode:bt-lr;",
                            \           "wm:btr": "writing-mode:bt-rl;",
                            \           "lts": "letter-spacing:|;",
                            \           "lts-n": "letter-spacing:normal;",
                            \           "f": "font:|;",
                            \           "f+": "font:${1:1em} ${2:Arial,sans-serif};",
                            \           "fw": "font-weight:|;",
                            \           "fw:n": "font-weight:normal;",
                            \           "fw:b": "font-weight:bold;",
                            \           "fw:br": "font-weight:bolder;",
                            \           "fw:lr": "font-weight:lighter;",
                            \           "fs": "font-style:${italic};",
                            \           "fs:n": "font-style:normal;",
                            \           "fs:i": "font-style:italic;",
                            \           "fs:o": "font-style:oblique;",
                            \           "fv": "font-variant:|;",
                            \           "fv:n": "font-variant:normal;",
                            \           "fv:sc": "font-variant:small-caps;",
                            \           "fz": "font-size:|;",
                            \           "fza": "font-size-adjust:|;",
                            \           "fza:n": "font-size-adjust:none;",
                            \           "ff": "font-family:|;",
                            \           "ff:s": "font-family:serif;",
                            \           "ff:ss": "font-family:sans-serif;",
                            \           "ff:c": "font-family:cursive;",
                            \           "ff:f": "font-family:fantasy;",
                            \           "ff:m": "font-family:monospace;",
                            \           "ff:a": "font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif;",
                            \           "ff:t": "font-family: \"Times New Roman\", Times, Baskerville, Georgia, serif;",
                            \           "ff:v": "font-family: Verdana, Geneva, sans-serif;",
                            \           "fef": "font-effect:|;",
                            \           "fef:n": "font-effect:none;",
                            \           "fef:eg": "font-effect:engrave;",
                            \           "fef:eb": "font-effect:emboss;",
                            \           "fef:o": "font-effect:outline;",
                            \           "fem": "font-emphasize:|;",
                            \           "femp": "font-emphasize-position:|;",
                            \           "femp:b": "font-emphasize-position:before;",
                            \           "femp:a": "font-emphasize-position:after;",
                            \           "fems": "font-emphasize-style:|;",
                            \           "fems:n": "font-emphasize-style:none;",
                            \           "fems:ac": "font-emphasize-style:accent;",
                            \           "fems:dt": "font-emphasize-style:dot;",
                            \           "fems:c": "font-emphasize-style:circle;",
                            \           "fems:ds": "font-emphasize-style:disc;",
                            \           "fsm": "font-smooth:|;",
                            \           "fsm:a": "font-smooth:auto;",
                            \           "fsm:n": "font-smooth:never;",
                            \           "fsm:aw": "font-smooth:always;",
                            \           "fst": "font-stretch:|;",
                            \           "fst:n": "font-stretch:normal;",
                            \           "fst:uc": "font-stretch:ultra-condensed;",
                            \           "fst:ec": "font-stretch:extra-condensed;",
                            \           "fst:c": "font-stretch:condensed;",
                            \           "fst:sc": "font-stretch:semi-condensed;",
                            \           "fst:se": "font-stretch:semi-expanded;",
                            \           "fst:e": "font-stretch:expanded;",
                            \           "fst:ee": "font-stretch:extra-expanded;",
                            \           "fst:ue": "font-stretch:ultra-expanded;",
                            \           "op": "opacity:|;",
                            \           "op+": "opacity: $1;\nfilter: alpha(opacity=$2);",
                            \           "op:ie": "filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=100);",
                            \           "op:ms": "-ms-filter:'progid:DXImageTransform.Microsoft.Alpha(Opacity=100)';",
                            \           "rsz": "resize:|;",
                            \           "rsz:n": "resize:none;",
                            \           "rsz:b": "resize:both;",
                            \           "rsz:h": "resize:horizontal;",
                            \           "rsz:v": "resize:vertical;",
                            \           "cur": "cursor:${pointer};",
                            \           "cur:a": "cursor:auto;",
                            \           "cur:d": "cursor:default;",
                            \           "cur:c": "cursor:crosshair;",
                            \           "cur:ha": "cursor:hand;",
                            \           "cur:he": "cursor:help;",
                            \           "cur:m": "cursor:move;",
                            \           "cur:p": "cursor:pointer;",
                            \           "cur:t": "cursor:text;",
                            \           "fxd": "flex-direction:|;",
                            \           "fxd:r": "flex-direction:row;",
                            \           "fxd:rr": "flex-direction:row-reverse;",
                            \           "fxd:c": "flex-direction:column;",
                            \           "fxd:cr": "flex-direction:column-reverse;",
                            \           "fxw": "flex-wrap: |;",
                            \           "fxw:n": "flex-wrap:nowrap;",
                            \           "fxw:w": "flex-wrap:wrap;",
                            \           "fxw:wr": "flex-wrap:wrap-reverse;",
                            \           "fxf": "flex-flow:|;",
                            \           "jc": "justify-content:|;",
                            \           "jc:fs": "justify-content:flex-start;",
                            \           "jc:fe": "justify-content:flex-end;",
                            \           "jc:c": "justify-content:center;",
                            \           "jc:sb": "justify-content:space-between;",
                            \           "jc:sa": "justify-content:space-around;",
                            \           "ai": "align-items:|;",
                            \           "ai:fs": "align-items:flex-start;",
                            \           "ai:fe": "align-items:flex-end;",
                            \           "ai:c": "align-items:center;",
                            \           "ai:b": "align-items:baseline;",
                            \           "ai:s": "align-items:stretch;",
                            \           "ac": "align-content:|;",
                            \           "ac:fs": "align-content:flex-start;",
                            \           "ac:fe": "align-content:flex-end;",
                            \           "ac:c": "align-content:center;",
                            \           "ac:sb": "align-content:space-between;",
                            \           "ac:sa": "align-content:space-around;",
                            \           "ac:s": "align-content:stretch;",
                            \           "ord": "order:|;",
                            \           "fxg": "flex-grow:|;",
                            \           "fxsh": "flex-shrink:|;",
                            \           "fxb": "flex-basis:|;",
                            \           "fx": "flex:|;",
                            \           "as": "align-self:|;",
                            \           "as:a": "align-self:auto;",
                            \           "as:fs": "align-self:flex-start;",
                            \           "as:fe": "align-self:flex-end;",
                            \           "as:c": "align-self:center;",
                            \           "as:b": "align-self:baseline;",
                            \           "as:s": "align-self:stretch;",
                            \           "pgbb": "page-break-before:|;",
                            \           "pgbb:au": "page-break-before:auto;",
                            \           "pgbb:al": "page-break-before:always;",
                            \           "pgbb:l": "page-break-before:left;",
                            \           "pgbb:r": "page-break-before:right;",
                            \           "pgbi": "page-break-inside:|;",
                            \           "pgbi:au": "page-break-inside:auto;",
                            \           "pgbi:av": "page-break-inside:avoid;",
                            \           "pgba": "page-break-after:|;",
                            \           "pgba:au": "page-break-after:auto;",
                            \           "pgba:al": "page-break-after:always;",
                            \           "pgba:l": "page-break-after:left;",
                            \           "pgba:r": "page-break-after:right;",
                            \           "orp": "orphans:|;",
                            \           "us": "user-select:${none};",
                            \           "wid": "widows:|;",
                            \           "wfsm": "-webkit-font-smoothing:${antialiased};",
                            \           "wfsm:a": "-webkit-font-smoothing:antialiased;",
                            \           "wfsm:s": "-webkit-font-smoothing:subpixel-antialiased;",
                            \           "wfsm:sa": "-webkit-font-smoothing:subpixel-antialiased;",
                            \           "wfsm:n": "-webkit-font-smoothing:none;"
                            \        },
                            \        'filters': 'fc',
                            \    },
                            \    'sass': {
                            \        'extends': 'css',
                            \        'snippets': {
                            \            '@if': "@if {\n\t|\n}",
                            \            '@e': "@else {\n\t|\n}",
                            \            '@in': "@include |",
                            \            '@ex': "@extend |",
                            \            '@mx': "@mixin {\n\t|\n}",
                            \            '@fn': "@function {\n\t|\n}",
                            \            '@r': "@return |",
                            \        },
                            \    },
                            \    'scss': {
                            \        'extends': 'css',
                            \    },
                            \    'less': {
                            \        'extends': 'css',
                            \    },
                            \    'css.drupal': {
                            \        'extends': 'css',
                            \    },
                            \    'html': {
                            \        'snippets': {
                            \            '!': "html:5",
                            \            '!!!': "<!DOCTYPE html>\n",
                            \            '!!!4t':  "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n",
                            \            '!!!4s':  "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n",
                            \            '!!!xt':  "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n",
                            \            '!!!xs':  "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n",
                            \            '!!!xxs': "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n",
                            \            'c': "<!-- |${child} -->",
                            \            'cc:ie6': "<!--[if lte IE 6]>\n\t${child}|\n<![endif]-->",
                            \            'cc:ie': "<!--[if IE]>\n\t${child}|\n<![endif]-->",
                            \            'cc:noie': "<!--[if !IE]><!-->\n\t${child}|\n<!--<![endif]-->",
                            \            'html:4t': "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n"
                            \                    ."<html lang=\"${lang}\">\n"
                            \                    ."<head>\n"
                            \                    ."\t<meta http-equiv=\"Content-Type\" content=\"text/html;charset=${charset}\">\n"
                            \                    ."\t<title></title>\n"
                            \                    ."</head>\n"
                            \                    ."<body>\n\t${child}|\n</body>\n"
                            \                    ."</html>",
                            \            'html:4s': "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n"
                            \                    ."<html lang=\"${lang}\">\n"
                            \                    ."<head>\n"
                            \                    ."\t<meta http-equiv=\"Content-Type\" content=\"text/html;charset=${charset}\">\n"
                            \                    ."\t<title></title>\n"
                            \                    ."</head>\n"
                            \                    ."<body>\n\t${child}|\n</body>\n"
                            \                    ."</html>",
                            \            'html:xt': "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n"
                            \                    ."<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"${lang}\">\n"
                            \                    ."<head>\n"
                            \                    ."\t<meta http-equiv=\"Content-Type\" content=\"text/html;charset=${charset}\" />\n"
                            \                    ."\t<title></title>\n"
                            \                    ."</head>\n"
                            \                    ."<body>\n\t${child}|\n</body>\n"
                            \                    ."</html>",
                            \            'html:xs': "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n"
                            \                    ."<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"${lang}\">\n"
                            \                    ."<head>\n"
                            \                    ."\t<meta http-equiv=\"Content-Type\" content=\"text/html;charset=${charset}\" />\n"
                            \                    ."\t<title></title>\n"
                            \                    ."</head>\n"
                            \                    ."<body>\n\t${child}|\n</body>\n"
                            \                    ."</html>",
                            \            'html:xxs': "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n"
                            \                    ."<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"${lang}\">\n"
                            \                    ."<head>\n"
                            \                    ."\t<meta http-equiv=\"Content-Type\" content=\"text/html;charset=${charset}\" />\n"
                            \                    ."\t<title></title>\n"
                            \                    ."</head>\n"
                            \                    ."<body>\n\t${child}|\n</body>\n"
                            \                    ."</html>",
                            \            'html:5': "<!DOCTYPE html>\n"
                            \                    ."<html lang=\"${lang}\">\n"
                            \                    ."<head>\n"
                            \                    ."\t<meta charset=\"${charset}\">\n"
                            \                    ."\t<title></title>\n"
                            \                    ."</head>\n"
                            \                    ."<body>\n\t${child}|\n</body>\n"
                            \                    ."</html>",
                            \        },
                            \        'default_attributes': {
                            \            'a': [{'href': ''}],
                            \            'a:link': [{'href': 'http://|'}],
                            \            'a:mail': [{'href': 'mailto:|'}],
                            \            'abbr': [{'title': ''}],
                            \            'acronym': [{'title': ''}],
                            \            'base': [{'href': ''}],
                            \            'bdo': [{'dir': ''}],
                            \            'bdo:r': [{'dir': 'rtl'}],
                            \            'bdo:l': [{'dir': 'ltr'}],
                            \            'del': [{'datetime': '${datetime}'}],
                            \            'ins': [{'datetime': '${datetime}'}],
                            \            'link:css': [{'rel': 'stylesheet'}, g:emmet_html5 ? {} : {'type': 'text/css'}, {'href': '|style.css'}, {'media': 'all'}],
                            \            'link:print': [{'rel': 'stylesheet'}, g:emmet_html5 ? {} : {'type': 'text/css'}, {'href': '|print.css'}, {'media': 'print'}],
                            \            'link:import': [{'rel': 'import'}, {'href': '|.html'}],
                            \            'link:im': [{'rel': 'import'}, {'href': '|.html'}],
                            \            'link:favicon': [{'rel': 'shortcut icon'}, {'type': 'image/x-icon'}, {'href': '|favicon.ico'}],
                            \            'link:touch': [{'rel': 'apple-touch-icon'}, {'href': '|favicon.png'}],
                            \            'link:rss': [{'rel': 'alternate'}, {'type': 'application/rss+xml'}, {'title': 'RSS'}, {'href': '|rss.xml'}],
                            \            'link:atom': [{'rel': 'alternate'}, {'type': 'application/atom+xml'}, {'title': 'Atom'}, {'href': 'atom.xml'}],
                            \            'meta:utf': [{'http-equiv': 'Content-Type'}, {'content': 'text/html;charset=UTF-8'}],
                            \            'meta:vp': [{'name': 'viewport'}, {'content': 'width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0'}],
                            \            'meta:win': [{'http-equiv': 'Content-Type'}, {'content': 'text/html;charset=Win-1251'}],
                            \            'meta:compat': [{'http-equiv': 'X-UA-Compatible'}, {'content': 'IE=7'}],
                            \            'style': g:emmet_html5 ? [] : [{'type': 'text/css'}],
                            \            'script': g:emmet_html5 ? [] : [{'type': 'text/javascript'}],
                            \            'script:src': (g:emmet_html5 ? [] : [{'type': 'text/javascript'}]) + [{'src': ''}],
                            \            'img': [{'src': ''}, {'alt': ''}],
                            \            'iframe': [{'src': ''}, {'frameborder': '0'}],
                            \            'embed': [{'src': ''}, {'type': ''}],
                            \            'object': [{'data': ''}, {'type': ''}],
                            \            'param': [{'name': ''}, {'value': ''}],
                            \            'map': {'name': ''},
                            \            'area': [{'shape': ''}, {'coords': ''}, {'href': ''}, {'alt': ''}],
                            \            'area:d': [{'shape': 'default'}, {'href': ''}, {'alt': ''}],
                            \            'area:c': [{'shape': 'circle'}, {'coords': ''}, {'href': ''}, {'alt': ''}],
                            \            'area:r': [{'shape': 'rect'}, {'coords': ''}, {'href': ''}, {'alt': ''}],
                            \            'area:p': [{'shape': 'poly'}, {'coords': ''}, {'href': ''}, {'alt': ''}],
                            \            'link': [{'rel': 'stylesheet'}, {'href': ''}],
                            \            'form': [{'action': ''}],
                            \            'form:get': [{'action': ''}, {'method': 'get'}],
                            \            'form:post': [{'action': ''}, {'method': 'post'}],
                            \            'form:upload': [{'action': ''}, {'method': 'post'}, {'enctype': 'multipart/form-data'}],
                            \            'label': [{'for': ''}],
                            \            'input': [{'type': ''}],
                            \            'input:hidden': [{'type': 'hidden'}, {'name': ''}],
                            \            'input:h': [{'type': 'hidden'}, {'name': ''}],
                            \            'input:text': [{'type': 'text'}, {'name': ''}, {'id': ''}],
                            \            'input:t': [{'type': 'text'}, {'name': ''}, {'id': ''}],
                            \            'input:search': [{'type': 'search'}, {'name': ''}, {'id': ''}],
                            \            'input:email': [{'type': 'email'}, {'name': ''}, {'id': ''}],
                            \            'input:url': [{'type': 'url'}, {'name': ''}, {'id': ''}],
                            \            'input:password': [{'type': 'password'}, {'name': ''}, {'id': ''}],
                            \            'input:p': [{'type': 'password'}, {'name': ''}, {'id': ''}],
                            \            'input:datetime': [{'type': 'datetime'}, {'name': ''}, {'id': ''}],
                            \            'input:date': [{'type': 'date'}, {'name': ''}, {'id': ''}],
                            \            'input:datetime-local': [{'type': 'datetime-local'}, {'name': ''}, {'id': ''}],
                            \            'input:month': [{'type': 'month'}, {'name': ''}, {'id': ''}],
                            \            'input:week': [{'type': 'week'}, {'name': ''}, {'id': ''}],
                            \            'input:time': [{'type': 'time'}, {'name': ''}, {'id': ''}],
                            \            'input:number': [{'type': 'number'}, {'name': ''}, {'id': ''}],
                            \            'input:color': [{'type': 'color'}, {'name': ''}, {'id': ''}],
                            \            'input:checkbox': [{'type': 'checkbox'}, {'name': ''}, {'id': ''}],
                            \            'input:c': [{'type': 'checkbox'}, {'name': ''}, {'id': ''}],
                            \            'input:radio': [{'type': 'radio'}, {'name': ''}, {'id': ''}],
                            \            'input:r': [{'type': 'radio'}, {'name': ''}, {'id': ''}],
                            \            'input:range': [{'type': 'range'}, {'name': ''}, {'id': ''}],
                            \            'input:file': [{'type': 'file'}, {'name': ''}, {'id': ''}],
                            \            'input:f': [{'type': 'file'}, {'name': ''}, {'id': ''}],
                            \            'input:submit': [{'type': 'submit'}, {'value': ''}],
                            \            'input:s': [{'type': 'submit'}, {'value': ''}],
                            \            'input:image': [{'type': 'image'}, {'src': ''}, {'alt': ''}],
                            \            'input:i': [{'type': 'image'}, {'src': ''}, {'alt': ''}],
                            \            'input:reset': [{'type': 'reset'}, {'value': ''}],
                            \            'input:button': [{'type': 'button'}, {'value': ''}],
                            \            'input:b': [{'type': 'button'}, {'value': ''}],
                            \            'select': [{'name': ''}, {'id': ''}],
                            \            'option': [{'value': ''}],
                            \            'textarea': [{'name': ''}, {'id': ''}, {'cols': '30'}, {'rows': '10'}],
                            \            'menu:context': [{'type': 'context'}],
                            \            'menu:c': [{'type': 'context'}],
                            \            'menu:toolbar': [{'type': 'toolbar'}],
                            \            'menu:t': [{'type': 'toolbar'}],
                            \            'video': [{'src': ''}],
                            \            'audio': [{'src': ''}],
                            \            'html:xml': [{'xmlns': 'http://www.w3.org/1999/xhtml'}, {'xml:lang': '${lang}'}],
                            \        },
                            \        'aliases': {
                            \            'link:*': 'link',
                            \            'meta:*': 'meta',
                            \            'area:*': 'area',
                            \            'bdo:*': 'bdo',
                            \            'form:*': 'form',
                            \            'input:*': 'input',
                            \            'script:*': 'script',
                            \            'html:*': 'html',
                            \            'a:*': 'a',
                            \            'menu:*': 'menu',
                            \            'bq': 'blockquote',
                            \            'acr': 'acronym',
                            \            'fig': 'figure',
                            \            'ifr': 'iframe',
                            \            'emb': 'embed',
                            \            'obj': 'object',
                            \            'src': 'source',
                            \            'cap': 'caption',
                            \            'colg': 'colgroup',
                            \            'fst': 'fieldset',
                            \            'btn': 'button',
                            \            'optg': 'optgroup',
                            \            'opt': 'option',
                            \            'tarea': 'textarea',
                            \            'leg': 'legend',
                            \            'sect': 'section',
                            \            'art': 'article',
                            \            'hdr': 'header',
                            \            'ftr': 'footer',
                            \            'adr': 'address',
                            \            'dlg': 'dialog',
                            \            'str': 'strong',
                            \            'sty': 'style',
                            \            'prog': 'progress',
                            \            'fset': 'fieldset',
                            \            'datag': 'datagrid',
                            \            'datal': 'datalist',
                            \            'kg': 'keygen',
                            \            'out': 'output',
                            \            'det': 'details',
                            \            'cmd': 'command',
                            \        },
                            \        'expandos': {
                            \            'ol': 'ol>li',
                            \            'ul': 'ul>li',
                            \            'dl': 'dl>dt+dd',
                            \            'map': 'map>area',
                            \            'table': 'table>tr>td',
                            \            'colgroup': 'colgroup>col',
                            \            'colg': 'colgroup>col',
                            \            'tr': 'tr>td',
                            \            'select': 'select>option',
                            \            'optgroup': 'optgroup>option',
                            \            'optg': 'optgroup>option',
                            \        },
                            \        'empty_elements': 'area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed,keygen,command',
                            \        'block_elements': 'address,applet,blockquote,button,center,dd,del,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,ins,isindex,li,link,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul,h1,h2,h3,h4,h5,h6',
                            \        'inline_elements': 'a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,script,small,span,strike,strong,sub,sup,textarea,tt,u,var',
                            \        'empty_element_suffix': g:emmet_html5 ? '>' : ' />',
                            \        'indent_blockelement': 0,
                            \        'block_all_childless': 0,
                            \    },
                            \    'elm': {
                            \        'indentation': '    ',
                            \        'extends': 'html',
                            \    },
                            \    'htmldjango': {
                            \        'extends': 'html',
                            \    },
                            \    'html.django_template': {
                            \        'extends': 'html',
                            \    },
                            \    'jade': {
                            \        'indentation': '  ',
                            \        'extends': 'html',
                            \        'snippets': {
                            \            '!': "html:5",
                            \            '!!!': "doctype html\n",
                            \            '!!!4t': "doctype HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"\n",
                            \            '!!!4s': "doctype HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"\n",
                            \            '!!!xt': "doctype transitional\n",
                            \            '!!!xs': "doctype strict\n",
                            \            '!!!xxs': "doctype 1.1\n",
                            \            'c': "\/\/ |${child}",
                            \            'html:4t': "doctype HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"\n"
                            \                    ."html(lang=\"${lang}\")\n"
                            \                    ."\thead\n"
                            \                    ."\t\tmeta(http-equiv=\"Content-Type\", content=\"text/html;charset=${charset}\")\n"
                            \                    ."\t\ttitle\n"
                            \                    ."\tbody\n\t\t${child}|",
                            \            'html:4s': "doctype HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"\n"
                            \                    ."html(lang=\"${lang}\")\n"
                            \                    ."\thead\n"
                            \                    ."\t\tmeta(http-equiv=\"Content-Type\", content=\"text/html;charset=${charset}\")\n"
                            \                    ."\t\ttitle\n"
                            \                    ."\tbody\n\t\t${child}|",
                            \            'html:xt': "doctype transitional\n"
                            \                    ."html(xmlns=\"http://www.w3.org/1999/xhtml\", xml:lang=\"${lang}\")\n"
                            \                    ."\thead\n"
                            \                    ."\t\tmeta(http-equiv=\"Content-Type\", content=\"text/html;charset=${charset}\")\n"
                            \                    ."\t\ttitle\n"
                            \                    ."\tbody\n\t\t${child}|",
                            \            'html:xs': "doctype strict\n"
                            \                    ."html(xmlns=\"http://www.w3.org/1999/xhtml\", xml:lang=\"${lang}\")\n"
                            \                    ."\thead\n"
                            \                    ."\t\tmeta(http-equiv=\"Content-Type\", content=\"text/html;charset=${charset}\")\n"
                            \                    ."\t\ttitle\n"
                            \                    ."\tbody\n\t\t${child}|",
                            \            'html:xxs': "doctype 1.1\n"
                            \                    ."html(xmlns=\"http://www.w3.org/1999/xhtml\", xml:lang=\"${lang}\")\n"
                            \                    ."\thead\n"
                            \                    ."\t\tmeta(http-equiv=\"Content-Type\", content=\"text/html;charset=${charset}\")\n"
                            \                    ."\t\ttitle\n"
                            \                    ."\tbody\n\t\t${child}|",
                            \            'html:5': "doctype html\n"
                            \                    ."html(lang=\"${lang}\")\n"
                            \                    ."\thead\n"
                            \                    ."\t\tmeta(charset=\"${charset}\")\n"
                            \                    ."\t\ttitle\n"
                            \                    ."\tbody\n\t\t${child}|",
                            \        },
                            \    },
                            \    'pug': {
                            \        'extends': 'jade',
                            \    },
                            \    'xsl': {
                            \        'extends': 'html',
                            \        'default_attributes': {
                            \            'tmatch': [{'match': ''}, {'mode': ''}],
                            \            'tname': [{'name': ''}],
                            \            'xsl:when': {'test': ''},
                            \            'var': [{'name': ''}, {'select': ''}],
                            \            'vari': {'name': ''},
                            \            'if': {'test': ''},
                            \            'call': {'name': ''},
                            \            'attr': {'name': ''},
                            \            'wp': [{'name': ''}, {'select': ''}],
                            \            'par': [{'name': ''}, {'select': ''}],
                            \            'val': {'select': ''},
                            \            'co': {'select': ''},
                            \            'each': {'select': ''},
                            \            'ap': [{'select': ''}, {'mode': ''}]
                            \        },
                            \        'aliases': {
                            \            'tmatch': 'xsl:template',
                            \            'tname': 'xsl:template',
                            \            'var': 'xsl:variable',
                            \            'vari': 'xsl:variable',
                            \            'if': 'xsl:if',
                            \            'choose': 'xsl:choose',
                            \            'call': 'xsl:call-template',
                            \            'wp': 'xsl:with-param',
                            \            'par': 'xsl:param',
                            \            'val': 'xsl:value-of',
                            \            'attr': 'xsl:attribute',
                            \            'co' : 'xsl:copy-of',
                            \            'each' : 'xsl:for-each',
                            \            'ap' : 'xsl:apply-templates',
                            \        },
                            \        'expandos': {
                            \            'choose': 'xsl:choose>xsl:when+xsl:otherwise',
                            \        }
                            \    },
                            \    'jsx': {
                            \        'extends': 'html',
                            \        'attribute_name': {'class': 'className', 'for': 'htmlFor'},
                            \        'empty_element_suffix': ' />',
                            \    },
                            \    'xslt': {
                            \        'extends': 'xsl',
                            \    },
                            \    'haml': {
                            \        'indentation': '  ',
                            \        'extends': 'html',
                            \        'snippets': {
                            \            'html:5': "!!! 5\n"
                            \                    ."%html{:lang => \"${lang}\"}\n"
                            \                    ."\t%head\n"
                            \                    ."\t\t%meta{:charset => \"${charset}\"}\n"
                            \                    ."\t\t%title\n"
                            \                    ."\t%body\n"
                            \                    ."\t\t${child}|\n",
                            \        },
                            \        'attribute_style': 'hash',
                            \    },
                            \    'slim': {
                            \        'indentation': '  ',
                            \        'extends': 'html',
                            \        'snippets': {
                            \            'html:5': "doctype 5\n"
                            \                    ."html lang=\"${lang}\"\n"
                            \                    ."\thead\n"
                            \                    ."\t\tmeta charset=\"${charset}\"\n"
                            \                    ."\t\ttitle\n"
                            \                    ."\tbody\n"
                            \                    ."\t\t${child}|\n",
                            \        },
                            \    },
                            \    'xhtml': {
                            \        'extends': 'html'
                            \    },
                            \    'mustache': {
                            \        'extends': 'html'
                            \    },
                            \    'xsd': {
                            \        'extends': 'html',
                            \        'snippets': {
                            \            'xsd:w3c': "<?xml version=\"1.0\"?>\n"
                            \                    ."<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n"
                            \                    ."\t<xsd:element name=\"\" type=\"\"/>\n"
                            \                    ."</xsd:schema>\n"
                            \        }
                            \    },
                            \}
                            
    1              0.000006 if exists('g:user_emmet_settings')
                              call emmet#mergeConfig(s:emmet_settings, g:user_emmet_settings)
    1              0.000001 endif
                            
    1              0.000006 let &cpoptions = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim:set et:

SCRIPT  /home/syphez/.vim/bundle/emmet-vim/autoload/emmet/lang.vim
Sourced 1 time
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000003 let s:exists = {}
    1              0.000002 function! emmet#lang#exists(type) abort
                              if len(a:type) == 0
                                return 0
                              elseif has_key(s:exists, a:type)
                                return s:exists[a:type]
                              endif
                              let s:exists[a:type] = len(globpath(&rtp, 'autoload/emmet/lang/'.a:type.'.vim')) > 0
                              return s:exists[a:type]
                            endfunction
                            
    1              0.000002 function! emmet#lang#type(type) abort
                              let type = a:type
                              let base = type
                              let settings = emmet#getSettings()
                              while base != ''
                                for b in split(base, '\.')
                                  if emmet#lang#exists(b)
                                    return b
                                  endif
                                  if has_key(settings, b) && has_key(settings[b], 'extends')
                                    let base = settings[b].extends
                                    break
                                  else
                                    let base = ''
                                  endif
                                endfor
                              endwhile
                              return 'html'
                            endfunction

SCRIPT  /home/syphez/.vim/bundle/emmet-vim/autoload/emmet/lang/html.vim
Sourced 1 time
Total time:   0.000542
 Self time:   0.000542

count  total (s)   self (s)
    1              0.000005 let s:bx = '{\%("[^"]*"\|''[^'']*''\|\$#\|\${\w\+}\|\$\+\|{[^{]\+\|[^{}]\)\{-}}'
    1              0.000018 let s:mx = '\([+>]\|[<^]\+\)\{-}\s*'
                            \     .'\((*\)\{-}\s*'
                            \       .'\([@#.]\{-}[a-zA-Z_\!][a-zA-Z0-9:_\!\-$]*\|' . s:bx . '\|\[[^\]]\+\]\)'
                            \       .'\('
                            \         .'\%('
                            \           .'\%(#{[{}a-zA-Z0-9_\-\$]\+\|#[a-zA-Z0-9_\-\$]\+\)'
                            \           .'\|\%(\[\%("[^"]*"\|[^"\]]*\)\+\]\)'
                            \           .'\|\%(\.{[{}a-zA-Z0-9_\-\$]\+\|\.[a-zA-Z0-9_\-\$]\+\)'
                            \         .'\)*'
                            \       .'\)'
                            \       .'\%(\(' . s:bx . '\+\)\)\{0,1}'
                            \         .'\%(\(@-\{0,1}[0-9]*\)\{0,1}\*\([0-9]\+\)\)\{0,1}'
                            \     .'\(\%()\%(\(@-\{0,1}[0-9]*\)\{0,1}\*[0-9]\+\)\{0,1}\)*\)'
                            
    1              0.000003 function! emmet#lang#html#findTokens(str) abort
                              let str = a:str
                              let [pos, last_pos] = [0, 0]
                              while 1
                                let tag = matchstr(str, '<[a-zA-Z].\{-}>', pos)
                                if len(tag) == 0
                                  break
                                endif
                                let pos = stridx(str, tag, pos) + len(tag)
                              endwhile
                              while 1
                                let tag = matchstr(str, '{%[^%]\{-}%}', pos)
                                if len(tag) == 0
                                  break
                                endif
                                let pos = stridx(str, tag, pos) + len(tag)
                              endwhile
                              let last_pos = pos
                              while len(str) > 0
                                let token = matchstr(str, s:mx, pos)
                                if token ==# ''
                                  break
                                endif
                                if token =~# '^\s'
                                  let token = matchstr(token, '^\s*\zs.*')
                                  let last_pos = stridx(str, token, pos)
                                endif
                                let pos = stridx(str, token, pos) + len(token)
                              endwhile
                              let str = a:str[last_pos :-1]
                              if str =~# '^\w\+="[^"]*$'
                                return ''
                              endif
                              return str
                            endfunction
                            
    1              0.000002 function! emmet#lang#html#parseIntoTree(abbr, type) abort
                              let abbr = a:abbr
                              let type = a:type
                            
                              let settings = emmet#getSettings()
                              if !has_key(settings, type)
                                let type = 'html'
                              endif
                              if len(type) == 0 | let type = 'html' | endif
                            
                              let indent = emmet#getIndentation(type)
                              let pmap = {
                              \'p': 'span',
                              \'ul': 'li',
                              \'ol': 'li',
                              \'table': 'tr',
                              \'tr': 'td',
                              \'tbody': 'tr',
                              \'thead': 'tr',
                              \'tfoot': 'tr',
                              \'colgroup': 'col',
                              \'select': 'option',
                              \'optgroup': 'option',
                              \'audio': 'source',
                              \'video': 'source',
                              \'object': 'param',
                              \'map': 'area'
                              \}
                            
                              let inlineLevel = split('a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var',',')
                            
                              let custom_expands = emmet#getResource(type, 'custom_expands', {})
                              if empty(custom_expands) && has_key(settings, 'custom_expands')
                                let custom_expands = settings['custom_expands']
                              endif
                            
                              " try 'foo' to (foo-x)
                              let rabbr = emmet#getExpandos(type, abbr)
                              if rabbr == abbr
                                " try 'foo+(' to (foo-x)
                                let rabbr = substitute(abbr, '\%(+\|^\)\([a-zA-Z][a-zA-Z0-9+]\+\)+\([(){}>]\|$\)', '\="(".emmet#getExpandos(type, submatch(1)).")".submatch(2)', 'i')
                              endif
                              let abbr = rabbr
                            
                              let root = emmet#newNode()
                              let parent = root
                              let last = root
                              let pos = []
                              while len(abbr)
                                " parse line
                                let match = matchstr(abbr, s:mx)
                                let str = substitute(match, s:mx, '\0', 'ig')
                                let operator = substitute(match, s:mx, '\1', 'ig')
                                let block_start = substitute(match, s:mx, '\2', 'ig')
                                let tag_name = substitute(match, s:mx, '\3', 'ig')
                                let attributes = substitute(match, s:mx, '\4', 'ig')
                                let value = substitute(match, s:mx, '\5', 'ig')
                                let basevalue = substitute(match, s:mx, '\6', 'ig')
                                let multiplier = 0 + substitute(match, s:mx, '\7', 'ig')
                                let block_end = substitute(match, s:mx, '\8', 'ig')
                                let custom = ''
                                let important = 0
                                if len(str) == 0
                                  break
                                endif
                                if tag_name =~# '^#'
                                  let attributes = tag_name . attributes
                                  let tag_name = ''
                                endif
                                if tag_name =~# '[^!]!$'
                                  let tag_name = tag_name[:-2]
                                  let important = 1
                                endif
                                if tag_name =~# '^\.'
                                  let attributes = tag_name . attributes
                                  let tag_name = ''
                                endif
                                if tag_name =~# '^\[.*\]$'
                                  let attributes = tag_name . attributes
                                  let tag_name = ''
                                endif
                            
                                for k in keys(custom_expands)
                                  if tag_name =~ k
                                    let custom = tag_name
                                    let tag_name = ''
                                    break
                                  endif
                                endfor
                            
                                if empty(tag_name)
                                  let pname = len(parent.child) > 0 ? parent.child[0].name : ''
                                  if !empty(pname) && has_key(pmap, pname)
                                    let tag_name = pmap[pname]
                                  elseif !empty(pname) && index(inlineLevel, pname) > -1
                                    let tag_name = 'span'
                                  elseif len(parent.child) == 0 || len(custom) == 0
                                    let tag_name = 'div'
                                  else
                                    let tag_name = custom
                                  endif
                                endif
                            
                                let basedirect = basevalue[1] ==# '-' ? -1 : 1
                                let basevalue = 0 + abs(basevalue[1:])
                                if multiplier <= 0 | let multiplier = 1 | endif
                            
                                " make default node
                                let current = emmet#newNode()
                            
                                let current.name = tag_name
                                let current.important = important
                            
                                " aliases
                                let aliases = emmet#getResource(type, 'aliases', {})
                                if has_key(aliases, tag_name)
                                  let current.name = aliases[tag_name]
                                endif
                            
                                let use_pipe_for_cursor = emmet#getResource(type, 'use_pipe_for_cursor', 1)
                            
                                " snippets
                                let snippets = emmet#getResource(type, 'snippets', {})
                                if !empty(snippets)
                                  let snippet_name = tag_name
                                  if has_key(snippets, snippet_name)
                                    let snippet = snippet_name
                                    while has_key(snippets, snippet)
                                      let snippet = snippets[snippet]
                                    endwhile
                                    if use_pipe_for_cursor
                                      let snippet = substitute(snippet, '|', '${cursor}', 'g')
                                    endif
                                    " just redirect to expanding
                                    if type == 'html' && snippet !~ '^\s*[{\[<]'
                                       return emmet#lang#html#parseIntoTree(snippet, a:type)
                                    endif
                                    let lines = split(snippet, "\n", 1)
                                    call map(lines, 'substitute(v:val, "\\(    \\|\\t\\)", escape(indent, "\\\\"), "g")')
                                    let current.snippet = join(lines, "\n")
                                    let current.name = ''
                                  endif
                                endif
                            
                                for k in keys(custom_expands)
                                  if tag_name =~# k
                                    let current.snippet = '${' . (empty(custom) ? tag_name : custom) . '}'
                                    let current.name = ''
                                    break
                                  elseif custom =~# k
                                    let current.snippet = '${' . custom . '}'
                                    let current.name = ''
                                    break
                                  endif
                                endfor
                            
                                " default_attributes
                                let default_attributes = emmet#getResource(type, 'default_attributes', {})
                                if !empty(default_attributes)
                                  for pat in [current.name, tag_name]
                                    if has_key(default_attributes, pat)
                                      if type(default_attributes[pat]) == 4
                                        let a = default_attributes[pat]
                                        let current.attrs_order += keys(a)
                                        if use_pipe_for_cursor
                                          for k in keys(a)
                                            let current.attr[k] = len(a[k]) ? substitute(a[k], '|', '${cursor}', 'g') : '${cursor}'
                                          endfor
                                        else
                                          for k in keys(a)
                                            let current.attr[k] = a[k]
                                          endfor
                                        endif
                                      else
                                        for a in default_attributes[pat]
                                          let current.attrs_order += keys(a)
                                          if use_pipe_for_cursor
                                            for k in keys(a)
                                              let current.attr[k] = len(a[k]) ? substitute(a[k], '|', '${cursor}', 'g') : '${cursor}'
                                            endfor
                                          else
                                            for k in keys(a)
                                              let current.attr[k] = a[k]
                                            endfor
                                          endif
                                        endfor
                                      endif
                                      if has_key(settings.html.default_attributes, current.name)
                                        let current.name = substitute(current.name, ':.*$', '', '')
                                      endif
                                      break
                                    endif
                                  endfor
                                endif
                            
                                " parse attributes
                                if len(attributes)
                                  let attr = attributes
                                  while len(attr)
                                    let item = matchstr(attr, '\(\%(\%(#[{}a-zA-Z0-9_\-\$]\+\)\|\%(\[\%("[^"]*"\|[^"\]]*\)\+\]\)\|\%(\.[{}a-zA-Z0-9_\-\$]\+\)*\)\)')
                                    if g:emmet_debug > 1
                                      echomsg 'attr=' . item
                                    endif
                                    if len(item) == 0
                                      break
                                    endif
                                    if item[0] ==# '#'
                                      let current.attr.id = item[1:]
                                    endif
                                    if item[0] ==# '.'
                                      let current.attr.class = substitute(item[1:], '\.', ' ', 'g')
                                    endif
                                    if item[0] ==# '['
                                      let atts = item[1:-2]
                                      if matchstr(atts, '^\s*\zs[0-9a-zA-Z_\-:]\+\(="[^"]*"\|=''[^'']*''\|=[^ ''"]\+\)') ==# ''
                                        let ks = []
                            			if has_key(default_attributes, current.name)
                                          let dfa = default_attributes[current.name]
                                          let ks = type(dfa) == 3 ? len(dfa) > 0 ? keys(dfa[0]) : [] : keys(dfa)
                                        endif
                                        if len(ks) == 0 && has_key(default_attributes, current.name . ':src')
                                          let dfa = default_attributes[current.name . ':src']
                                          let ks = type(dfa) == 3 ? len(dfa) > 0 ? keys(dfa[0]) : [] : keys(dfa)
                                        endif
                                        if len(ks) > 0
                                          let current.attr[ks[0]] = atts
                                        else
                                          let current.attr[atts] = ''
                                        endif
                                      else
                                        while len(atts)
                                          let amat = matchstr(atts, '^\s*\zs\([0-9a-zA-Z-:]\+\%(={{.\{-}}}\|="[^"]*"\|=''[^'']*''\|=[^ ''"]\+\|[^ ''"\]]*\)\{0,1}\)')
                                          if len(amat) == 0
                                            break
                                          endif
                                          let key = split(amat, '=')[0]
                                          let Val = amat[len(key)+1:]
                                          if key =~# '\.$' && Val ==# ''
                                            let key = key[:-2]
                                            unlet Val
                                            let Val = function('emmet#types#true')
                                          elseif Val =~# '^["'']'
                                            let Val = Val[1:-2]
                                          endif
                                          let current.attr[key] = Val
                                          if index(current.attrs_order, key) == -1
                                            let current.attrs_order += [key]
                                          endif
                                          let atts = atts[stridx(atts, amat) + len(amat):]
                                          unlet Val
                                        endwhile
                                      endif
                                    endif
                                    let attr = substitute(strpart(attr, len(item)), '^\s*', '', '')
                                  endwhile
                                endif
                            
                                " parse text
                                if tag_name =~# '^{.*}$'
                                  let current.name = ''
                                  let current.value = tag_name
                                else
                                  let current.value = value
                                endif
                                let current.basedirect = basedirect
                                let current.basevalue = basevalue
                                let current.multiplier = multiplier
                            
                                " parse step inside/outside
                                if !empty(last)
                                  if operator =~# '>'
                                    unlet! parent
                                    let parent = last
                                    let current.parent = last
                                    let current.pos = last.pos + 1
                                  else
                                    let current.parent = parent
                                    let current.pos = last.pos
                                  endif
                                else
                                  let current.parent = parent
                                  let current.pos = 1
                                endif
                                if operator =~# '[<^]'
                                  for c in range(len(operator))
                                    let tmp = parent.parent
                                    if empty(tmp)
                                      break
                                    endif
                                    let parent = tmp
                                    let current.parent = tmp
                                  endfor
                                endif
                            
                                call add(parent.child, current)
                                let last = current
                            
                                " parse block
                                if block_start =~# '('
                                  if operator =~# '>'
                                    let last.pos += 1
                                  endif
                                  let last.block = 1
                                  for n in range(len(block_start))
                                    let pos += [last.pos]
                                  endfor
                                endif
                                if block_end =~# ')'
                                  for n in split(substitute(substitute(block_end, ' ', '', 'g'), ')', ',),', 'g'), ',')
                                    if n ==# ')'
                                      if len(pos) > 0 && last.pos >= pos[-1]
                                        for c in range(last.pos - pos[-1])
                                          let tmp = parent.parent
                                          if !has_key(tmp, 'parent')
                                            break
                                          endif
                                          let parent = tmp
                                        endfor
                                        if len(pos) > 0
                                          call remove(pos, -1)
                                        endif
                                        let last = parent
                                        let last.pos += 1
                                      endif
                                    elseif len(n)
                                      let st = 0
                                      for nc in range(len(last.child))
                                        if last.child[nc].block
                                          let st = nc
                                          break
                                        endif
                                      endfor
                                      let cl = last.child[st :]
                                      let cls = []
                                      for c in range(n[1:])
                                        for cc in cl
                                          if cc.multiplier > 1
                                            let cc.basedirect = c + 1
                                          else
                                            let cc.basevalue = c + 1
                                          endif
                                        endfor
                                        let cls += deepcopy(cl)
                                      endfor
                                      if st > 0
                                        let last.child = last.child[:st-1] + cls
                                      else
                                        let last.child = cls
                                      endif
                                    endif
                                  endfor
                                endif
                                let abbr = abbr[stridx(abbr, match) + len(match):]
                                if abbr == '/'
                                  let current.empty = 1
                                endif
                            
                                if g:emmet_debug > 1
                                  echomsg 'str='.str
                                  echomsg 'block_start='.block_start
                                  echomsg 'tag_name='.tag_name
                                  echomsg 'operator='.operator
                                  echomsg 'attributes='.attributes
                                  echomsg 'value='.value
                                  echomsg 'basevalue='.basevalue
                                  echomsg 'multiplier='.multiplier
                                  echomsg 'block_end='.block_end
                                  echomsg 'abbr='.abbr
                                  echomsg 'pos='.string(pos)
                                  echomsg '---'
                                endif
                              endwhile
                              return root
                            endfunction
                            
    1              0.000003 function! s:dollar_add(base,no) abort
                              if a:base > 0
                                return a:base + a:no - 1
                              elseif a:base < 0
                                return a:base - a:no + 1
                              else
                                return a:no
                              endif
                            endfunction
                            
    1              0.000003 function! emmet#lang#html#toString(settings, current, type, inline, filters, itemno, indent) abort
                              let settings = a:settings
                              let current = a:current
                              let type = a:type
                              let inline = a:inline
                              let filters = a:filters
                              let itemno = a:itemno
                              let indent = a:indent
                              let dollar_expr = emmet#getResource(type, 'dollar_expr', 1)
                              let q = emmet#getResource(type, 'quote_char', '"')
                              let ct = emmet#getResource(type, 'comment_type', 'both')
                              let an = emmet#getResource(type, 'attribute_name', {})
                              let empty_element_suffix = emmet#getResource(type, 'empty_element_suffix', settings.html.empty_element_suffix)
                            
                              if emmet#useFilter(filters, 'haml')
                                return emmet#lang#haml#toString(settings, current, type, inline, filters, itemno, indent)
                              endif
                              if emmet#useFilter(filters, 'slim')
                                return emmet#lang#slim#toString(settings, current, type, inline, filters, itemno, indent)
                              endif
                            
                              let comment = ''
                              let current_name = current.name
                              if dollar_expr
                                let current_name = substitute(current_name, '\$$', itemno+1, '')
                              endif
                            
                              let str = ''
                              if len(current_name) == 0
                                let text = current.value[1:-2]
                                if dollar_expr
                                  " TODO: regexp engine specified
                                  let nr = itemno + 1
                                  if exists('&regexpengine')
                                    let text = substitute(text, '\%#=1\%(\\\)\@\<!\(\$\+\)\(@-\?[0-9]\+\)\{0,1}\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d",s:dollar_add(submatch(2)[1:],nr)).submatch(3)', 'g')
                                  else
                                    let text = substitute(text, '\%(\\\)\@\<!\(\$\+\)\(@-\?[0-9]\+\)\{0,1}\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d",s:dollar_add(submatch(2)[1:],nr).submatch(3)', 'g')
                                  endif
                                  let text = substitute(text, '\${nr}', "\n", 'g')
                                  let text = substitute(text, '\\\$', '$', 'g')
                                endif
                                return text
                              endif
                              if len(current_name) > 0
                                let str .= '<' . current_name
                              endif
                              for attr in emmet#util#unique(current.attrs_order + keys(current.attr))
                                if !has_key(current.attr, attr)
                                  continue
                                endif
                                let Val = current.attr[attr]
                                if type(Val) == 2 && Val == function('emmet#types#true')
                                  unlet Val
                                  let Val = 'true'
                                  if g:emmet_html5
                                    let str .= ' ' . attr
                                  else
                                    let str .= ' ' . attr . '=' . q . attr . q
                                  endif
                                  if emmet#useFilter(filters, 'c')
                                    if attr ==# 'id' | let comment .= '#' . Val | endif
                                    if attr ==# 'class' | let comment .= '.' . Val | endif
                                  endif
                                else
                                  if dollar_expr
                                    while Val =~# '\$\([^#{]\|$\)'
                                      " TODO: regexp engine specified
                                      if exists('&regexpengine')
                                        let Val = substitute(Val, '\%#=1\(\$\+\)\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d", itemno+1).submatch(2)', 'g')
                                      else
                                        let Val = substitute(Val, '\(\$\+\)\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d", itemno+1).submatch(2)', 'g')
                                      endif
                                    endwhile
                                    let attr = substitute(attr, '\$$', itemno+1, '')
                                  endif
                                  if attr ==# 'class' && emmet#useFilter(filters, 'bem')
                                    let vals = split(Val, '\s\+')
                                    let Val = ''
                                    let lead = ''
                                    for _val in vals
                                      if len(Val) > 0
                                        let Val .= ' '
                                      endif
                                      if _val =~# '^_'
                                        if has_key(current.parent.attr, 'class')
                                          let lead = current.parent.attr["class"]
                                          if _val =~# '^__'
                                            let Val .= lead . _val
                                          else
                                            let Val .= lead . ' ' . lead . _val
                                          endif
                                        else
                                          let lead = split(vals[0], '_')[0]
                                          let Val .= lead . _val
                                        endif
                                      elseif _val =~# '^-'
                                        for l in split(_val, '_')
                                          if len(Val) > 0
                                            let Val .= ' '
                                          endif
                                          let l = substitute(l, '^-', '__', '')
                                          if len(lead) == 0
                                            let pattr = current.parent.attr
                                            if has_key(pattr, 'class')
                                              let lead = split(pattr['class'], '\s\+')[0]
                                            endif
                                          endif
                                          let Val .= lead . l
                                          let lead .= l . '_'
                                        endfor
                                      else
                                        let Val .= _val
                                      endif
                                    endfor
                                  endif
                                  if has_key(an, attr)
                                    let attr = an[attr]
                                  endif
                                  if emmet#isExtends(type, 'jsx') && Val =~ '^{.*}$'
                                    let str .= ' ' . attr . '=' . Val
                                  else
                                    let str .= ' ' . attr . '=' . q . Val . q
                                  endif
                                  if emmet#useFilter(filters, 'c')
                                    if attr ==# 'id' | let comment .= '#' . Val | endif
                                    if attr ==# 'class' | let comment .= '.' . Val | endif
                                  endif
                                endif
                                unlet Val
                              endfor
                              if len(comment) > 0 && ct ==# 'both'
                                let str = '<!-- ' . comment . " -->\n" . str
                              endif
                              if current.empty
                                let str .= ' />'
                              elseif stridx(','.settings.html.empty_elements.',', ','.current_name.',') != -1
                                let str .= empty_element_suffix
                              else
                                let str .= '>'
                                let text = current.value[1:-2]
                                if dollar_expr
                                  " TODO: regexp engine specified
                                  let nr = itemno + 1
                                  if exists('&regexpengine')
                                    let text = substitute(text, '\%#=1\%(\\\)\@\<!\(\$\+\)\(@-\?[0-9]\+\)\{0,1}\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d",s:dollar_add(submatch(2)[1:],nr)).submatch(3)', 'g')
                                  else
                                    let text = substitute(text, '\%(\\\)\@\<!\(\$\+\)\(@-\?[0-9]\+\)\{0,1}\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d",s:dollar_add(submatch(2)[1:],nr)).submatch(3)', 'g')
                                  endif
                                  let text = substitute(text, '\${nr}', "\n", 'g')
                                  let text = substitute(text, '\\\$', '$', 'g')
                                  if text != ''
                                    let str = substitute(str, '\("\zs$#\ze"\|\s\zs\$#"\|"\$#\ze\s\)', text, 'g')
                                  endif
                                endif
                                let str .= text
                                let nc = len(current.child)
                                let dr = 0
                                if nc > 0
                                  for n in range(nc)
                                    let child = current.child[n]
                                    if child.multiplier > 1 || (child.multiplier == 1 && len(child.child) > 0 && stridx(','.settings.html.inline_elements.',', ','.current_name.',') == -1) || settings.html.block_all_childless
                                      let str .= "\n" . indent
                                      let dr = 1
                                    elseif len(current_name) > 0 && stridx(','.settings.html.inline_elements.',', ','.current_name.',') == -1
                                      if nc > 1 || (len(child.name) > 0 && stridx(','.settings.html.inline_elements.',', ','.child.name.',') == -1)
                                        let str .= "\n" . indent
                                        let dr = 1
                                      elseif current.multiplier == 1 && nc == 1 && len(child.name) == 0
                                        let str .= "\n" . indent
                                        let dr = 1
                                      endif
                                    endif
                                    let inner = emmet#toString(child, type, 0, filters, itemno, indent)
                                    let inner = substitute(inner, "^\n", '', 'g')
                                    let inner = substitute(inner, "\n", "\n" . escape(indent, '\'), 'g')
                                    let inner = substitute(inner, "\n" . escape(indent, '\') . '$', '', 'g')
                                    let str .= inner
                                  endfor
                                else
                                  if settings.html.indent_blockelement && len(current_name) > 0 && stridx(','.settings.html.inline_elements.',', ','.current_name.',') == -1 || settings.html.block_all_childless
                                    let str .= "\n" . indent . '${cursor}' . "\n"
                                  else
                                    let str .= '${cursor}'
                                  endif
                                endif
                                if dr
                                  let str .= "\n"
                                endif
                                let str .= '</' . current_name . '>'
                              endif
                              if len(comment) > 0
                                if ct ==# 'lastonly'
                                  let str .= '<!-- ' . comment . ' -->'
                                else
                                  let str .= "\n<!-- /" . comment . ' -->'
                                endif
                              endif
                              if len(current_name) > 0 && current.multiplier > 0 || stridx(','.settings.html.block_elements.',', ','.current_name.',') != -1
                                let str .= "\n"
                              endif
                              return str
                            endfunction
                            
    1              0.000002 function! emmet#lang#html#imageSize() abort
                              let img_region = emmet#util#searchRegion('<img\s', '>')
                              if !emmet#util#regionIsValid(img_region) || !emmet#util#cursorInRegion(img_region)
                                return
                              endif
                              let content = emmet#util#getContent(img_region)
                              if content !~# '^<img[^><]\+>$'
                                return
                              endif
                              let current = emmet#lang#html#parseTag(content)
                              if empty(current) || !has_key(current.attr, 'src')
                                return
                              endif
                              let fn = current.attr.src
                              if fn =~# '^\s*$'
                                return
                              elseif fn !~# '^\(/\|http\)'
                                let fn = simplify(expand('%:h') . '/' . fn)
                              endif
                            
                              let [width, height] = emmet#util#getImageSize(fn)
                              if width == -1 && height == -1
                                return
                              endif
                              let current.attr.width = width
                              let current.attr.height = height
                              let current.attrs_order += ['width', 'height']
                              let html = substitute(emmet#toString(current, 'html', 1), '\n', '', '')
                              let html = substitute(html, '\${cursor}', '', '')
                              call emmet#util#setContent(img_region, html)
                            endfunction
                            
    1              0.000002 function! emmet#lang#html#encodeImage() abort
                              let img_region = emmet#util#searchRegion('<img\s', '>')
                              if !emmet#util#regionIsValid(img_region) || !emmet#util#cursorInRegion(img_region)
                                return
                              endif
                              let content = emmet#util#getContent(img_region)
                              if content !~# '^<img[^><]\+>$'
                                return
                              endif
                              let current = emmet#lang#html#parseTag(content)
                              if empty(current) || !has_key(current.attr, 'src')
                                return
                              endif
                              let fn = current.attr.src
                              if fn !~# '^\(/\|http\)'
                                let fn = simplify(expand('%:h') . '/' . fn)
                              endif
                            
                              let [width, height] = emmet#util#getImageSize(fn)
                              if width == -1 && height == -1
                                return
                              endif
                              let current.attr.width = width
                              let current.attr.height = height
                              let html = emmet#toString(current, 'html', 1)
                              call emmet#util#setContent(img_region, html)
                            endfunction
                            
    1              0.000002 function! emmet#lang#html#parseTag(tag) abort
                              let current = emmet#newNode()
                              let mx = '<\([a-zA-Z][a-zA-Z0-9]*\)\(\%(\s[a-zA-Z][a-zA-Z0-9]\+=\%([^"'' \t]\+\|"[^"]\{-}"\|''[^'']\{-}''\)\s*\)*\)\(/\{0,1}\)>'
                              let match = matchstr(a:tag, mx)
                              let current.name = substitute(match, mx, '\1', 'i')
                              let attrs = substitute(match, mx, '\2', 'i')
                              let mx = '\([a-zA-Z0-9]\+\)=\%(\([^"'' \t]\+\)\|"\([^"]\{-}\)"\|''\([^'']\{-}\)''\)'
                              while len(attrs) > 0
                                let match = matchstr(attrs, mx)
                                if len(match) == 0
                                  break
                                endif
                                let attr_match = matchlist(match, mx)
                                let name = attr_match[1]
                                let value = len(attr_match[2]) ? attr_match[2] : attr_match[3]
                                let current.attr[name] = value
                                let current.attrs_order += [name]
                                let attrs = attrs[stridx(attrs, match) + len(match):]
                              endwhile
                              return current
                            endfunction
                            
    1              0.000002 function! emmet#lang#html#toggleComment() abort
                              let orgpos = getpos('.')
                              let curpos = getpos('.')
                              let mx = '<\%#[^>]*>'
                              while 1
                                let block = emmet#util#searchRegion('<!--', '-->')
                                if emmet#util#regionIsValid(block)
                                  let block[1][1] += 2
                                  let content = emmet#util#getContent(block)
                                  let content = substitute(content, '^<!--\s\(.*\)\s-->$', '\1', '')
                                  call emmet#util#setContent(block, content)
                                  silent! call setpos('.', orgpos)
                                  return
                                endif
                                let block = emmet#util#searchRegion('<[^>]', '>')
                                if !emmet#util#regionIsValid(block)
                                  let pos1 = searchpos('<', 'bcW')
                                  if pos1[0] == 0 && pos1[1] == 0
                                    return
                                  endif
                                  let curpos = getpos('.')
                                  continue
                                endif
                                let pos1 = block[0]
                                let pos2 = block[1]
                                let content = emmet#util#getContent(block)
                                let tag_name = matchstr(content, '^<\zs/\{0,1}[^ \r\n>]\+')
                                if tag_name[0] ==# '/'
                                  call setpos('.', [0, pos1[0], pos1[1], 0])
                                  let pos2 = searchpairpos('<'. tag_name[1:] . '\>[^>]*>', '', '</' . tag_name[1:] . '>', 'bnW')
                                  let pos1 = searchpos('>', 'cneW')
                                  let block = [pos2, pos1]
                                elseif tag_name =~# '/$'
                                  if !emmet#util#pointInRegion(orgpos[1:2], block)
                                    " it's broken tree
                                    call setpos('.', orgpos)
                                    let block = emmet#util#searchRegion('>', '<')
                                    let content = '><!-- ' . emmet#util#getContent(block)[1:-2] . ' --><'
                                    call emmet#util#setContent(block, content)
                                    silent! call setpos('.', orgpos)
                                    return
                                  endif
                                else
                                  call setpos('.', [0, pos2[0], pos2[1], 0])
                                  let pos3 = searchpairpos('<'. tag_name . '\>[^>]*>', '', '</' . tag_name . '>', 'nW')
                                  if pos3 == [0, 0]
                                    let block = [pos1, pos2]
                                  else
                                    call setpos('.', [0, pos3[0], pos3[1], 0])
                                    let pos2 = searchpos('>', 'neW')
                                    let block = [pos1, pos2]
                                  endif
                                endif
                                if !emmet#util#regionIsValid(block)
                                  silent! call setpos('.', orgpos)
                                  return
                                endif
                                if emmet#util#pointInRegion(curpos[1:2], block)
                                  let content = '<!-- ' . emmet#util#getContent(block) . ' -->'
                                  call emmet#util#setContent(block, content)
                                  silent! call setpos('.', orgpos)
                                  return
                                endif
                              endwhile
                            endfunction
                            
    1              0.000003 function! emmet#lang#html#balanceTag(flag) range abort
                              let vblock = emmet#util#getVisualBlock()
                              if a:flag == -2 || a:flag == 2
                                let curpos = [0, line("'<"), col("'<"), 0]
                              else
                                let curpos = emmet#util#getcurpos()
                              endif
                              let settings = emmet#getSettings()
                            
                              if a:flag > 0
                                let mx = '<\([a-zA-Z][a-zA-Z0-9:_\-]*\)[^>]*'
                                let last = curpos[1:2]
                                while 1
                                  let pos1 = searchpos(mx, 'bW')
                                  let content = matchstr(getline(pos1[0])[pos1[1]-1:], mx)
                                  let tag_name = matchstr(content, '^<\zs[a-zA-Z0-9:_\-]*\ze')
                                  if stridx(','.settings.html.empty_elements.',', ','.tag_name.',') != -1
                                    let pos2 = searchpos('>', 'nW')
                                  else
                                    let pos2 = searchpairpos('<' . tag_name . '[^>]*>', '', '</'. tag_name . '\zs>', 'nW')
                                  endif
                                  let block = [pos1, pos2]
                                  if pos1[0] == 0 && pos1[1] == 0
                                    break
                                  endif
                                  if emmet#util#pointInRegion(last, block) && emmet#util#regionIsValid(block)
                                    call emmet#util#selectRegion(block)
                                    return
                                  endif
                                  if pos1 == last
                                    break
                                  endif
                                  let last = pos1
                                endwhile
                              else
                                let mx = '<\([a-zA-Z][a-zA-Z0-9:_\-]*\)[^>]*>'
                                while 1
                                  let pos1 = searchpos(mx, 'W')
                                  if pos1 == curpos[1:2]
                                    let pos1 = searchpos(mx . '\zs', 'W')
                                    let pos2 = searchpos('.\ze<', 'W')
                                    let block = [pos1, pos2]
                                    if emmet#util#regionIsValid(block)
                                      call emmet#util#selectRegion(block)
                                      return
                                    endif
                                  endif
                                  let content = matchstr(getline(pos1[0])[pos1[1]-1:], mx)
                                  let tag_name = matchstr(content, '^<\zs[a-zA-Z0-9:_\-]*\ze')
                                  if stridx(','.settings.html.empty_elements.',', ','.tag_name.',') != -1
                                    let pos2 = searchpos('>', 'nW')
                                  else
                                    let pos2 = searchpairpos('<' . tag_name . '[^>]*>', '', '</'. tag_name . '\zs>', 'nW')
                                  endif
                                  let block = [pos1, pos2]
                                  if pos1[0] == 0 && pos1[1] == 0
                                    break
                                  endif
                                  if emmet#util#regionIsValid(block)
                                    call emmet#util#selectRegion(block)
                                    return
                                  endif
                                endwhile
                              endif
                              if a:flag == -2 || a:flag == 2
                                silent! exe 'normal! gv'
                              else
                                call setpos('.', curpos)
                              endif
                            endfunction
                            
    1              0.000002 function! emmet#lang#html#moveNextPrevItem(flag) abort
                              silent! exe "normal \<esc>"
                              let mx = '\%([0-9a-zA-Z-:]\+\%(="[^"]*"\|=''[^'']*''\|[^ ''">\]]*\)\{0,1}\)'
                              let pos = searchpos('\s'.mx.'\zs', '')
                              if pos != [0,0]
                                call feedkeys('v?\s\zs'.mx."\<cr>", '')
                              endif
                            endfunction
                            
    1              0.000002 function! emmet#lang#html#moveNextPrev(flag) abort
                              let pos = search('\%(</\w\+\)\@<!\zs><\/\|\(""\)\|^\(\s*\)$', a:flag ? 'Wpb' : 'Wp')
                              if pos == 3
                                startinsert!
                              elseif pos != 0
                                silent! normal! l
                                startinsert
                              endif
                            endfunction
                            
    1              0.000001 function! emmet#lang#html#splitJoinTag() abort
                              let curpos = emmet#util#getcurpos()
                              while 1
                                let mx = '<\(/\{0,1}[a-zA-Z][a-zA-Z0-9]*\)\%(\%(\s[a-zA-Z][a-zA-Z0-9]\+=\%([^"'' \t]\+\|"[^"]\{-}"\|''[^'']\{-}''\)\s*\)*\)\%(/\{0,1}\)>'
                                let pos1 = searchpos(mx, 'bcnW')
                                let content = matchstr(getline(pos1[0])[pos1[1]-1:], mx)
                                let tag_name = substitute(content, '^<\(/\{0,1}[a-zA-Z][a-zA-Z0-9:_\-]*\).*$', '\1', '')
                                let block = [pos1, [pos1[0], pos1[1] + len(content) - 1]]
                                if content[-2:] ==# '/>' && emmet#util#cursorInRegion(block)
                                  let content = substitute(content[:-3], '\s*$', '', '')  . '></' . tag_name . '>'
                                  call emmet#util#setContent(block, content)
                                  call setpos('.', [0, block[0][0], block[0][1], 0])
                                  return
                                else
                                  if tag_name[0] ==# '/'
                                    let pos1 = searchpos('<' . tag_name[1:] . '[^a-zA-Z0-9]', 'bcnW')
                                    call setpos('.', [0, pos1[0], pos1[1], 0])
                                    let pos2 = searchpos('</' . tag_name[1:] . '>', 'cneW')
                                  else
                                    let pos2 = searchpos('</' . tag_name . '>', 'cneW')
                                  endif
                                  let block = [pos1, pos2]
                                  let content = emmet#util#getContent(block)
                                  if emmet#util#pointInRegion(curpos[1:2], block) && content[1:] !~# '<' . tag_name . '[^a-zA-Z0-9]*[^>]*>'
                                    let content = matchstr(content, mx)[:-2] . ' />'
                                    call emmet#util#setContent(block, content)
                                    call setpos('.', [0, block[0][0], block[0][1], 0])
                                    return
                                  else
                                    if block[0][0] > 0
                                      call setpos('.', [0, block[0][0]-1, block[0][1], 0])
                                    else
                                      call setpos('.', curpos)
                                      return
                                    endif
                                  endif
                                endif
                              endwhile
                            endfunction
                            
    1              0.000002 function! emmet#lang#html#removeTag() abort
                              let curpos = emmet#util#getcurpos()
                              while 1
                                let mx = '<\(/\{0,1}[a-zA-Z][a-zA-Z0-9:_\-]*\)[^>]*'
                                let pos1 = searchpos(mx, 'bcnW')
                                let content = matchstr(getline(pos1[0])[pos1[1]-1:], mx)
                                let tag_name = matchstr(content, '^<\zs/\{0,1}[a-zA-Z0-9:_\-]*')
                                let block = [pos1, [pos1[0], pos1[1] + len(content) - 1]]
                                if content[-2:] ==# '/>' && emmet#util#cursorInRegion(block)
                                  call emmet#util#setContent(block, '')
                                  call setpos('.', [0, block[0][0], block[0][1], 0])
                                  return
                                else
                                  if tag_name[0] ==# '/'
                                    let pos1 = searchpos('<' . tag_name[1:] . '[^a-zA-Z0-9]', 'bcnW')
                                    call setpos('.', [0, pos1[0], pos1[1], 0])
                                    let pos2 = searchpos('</' . tag_name[1:] . '>', 'cneW')
                                  else
                                    let pos2 = searchpos('</' . tag_name . '>', 'cneW')
                                  endif
                                  let block = [pos1, pos2]
                                  let content = emmet#util#getContent(block)
                                  if emmet#util#pointInRegion(curpos[1:2], block) && content[1:] !~# '^<' . tag_name . '[^a-zA-Z0-9]'
                                    call emmet#util#setContent(block, '')
                                    call setpos('.', [0, block[0][0], block[0][1], 0])
                                    return
                                  else
                                    if block[0][0] > 0
                                      call setpos('.', [0, block[0][0]-1, block[0][1], 0])
                                    else
                                      call setpos('.', curpos)
                                      return
                                    endif
                                  endif
                                endif
                              endwhile
                            endfunction

FUNCTION  emmet#newNode()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet.vim line 178
Called 2 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    2              0.000019   return { 'name': '', 'attr': {}, 'child': [], 'snippet': '', 'basevalue': 0, 'basedirect': 1, 'multiplier': 1, 'parent': {}, 'value': '', 'pos': 0, 'important': 0, 'attrs_order': ['id', 'class'], 'block': 0, 'empty': 0 }

FUNCTION  emmet#expandAbbr()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet.vim line 508
Called 1 time
Total time:   0.011106
 Self time:   0.000702

count  total (s)   self (s)
    1   0.000527   0.000010   let type = emmet#getFileType()
    1   0.000407   0.000012   let rtype = emmet#lang#type(emmet#getFileType(1))
    1   0.000045   0.000011   let indent = emmet#getIndentation(type)
    1              0.000001   let expand = ''
    1              0.000001   let line = ''
    1              0.000001   let part = ''
    1              0.000001   let rest = ''
                            
    1   0.000154   0.000006   let filters = emmet#getFilters(type)
    1              0.000002   if len(filters) ==# 0
    1              0.000002     let filters = ['html']
    1              0.000001   endif
                            
    1              0.000001   if a:mode ==# 2
                                let leader = substitute(input('Tag: ', ''), '^\s*\(.*\)\s*$', '\1', 'g')
                                if len(leader) ==# 0
                                  return ''
                                endif
                                if leader =~# s:filtermx
                                  let filters = map(split(matchstr(leader, s:filtermx)[1:], '\s*[^\\]\zs,\s*'), 'substitute(v:val, "\\\\\\\\zs.\\\\ze", "&", "g")')
                                  let leader = substitute(leader, s:filtermx, '', '')
                                endif
                                if leader =~# '\*'
                                  let query = substitute(leader, '*', '*' . (a:lastline - a:firstline + 1), '')
                                  if query !~# '}\s*$' && query !~# '\$#'
                                    let query .= '>{$#}'
                                  endif
                                  if emmet#useFilter(filters, '/')
                                    let spl = emmet#splitFilterArg(filters)
                                    let fline = getline(a:firstline)
                                    let query = substitute(query, '>\{0,1}{\$#}\s*$', '{\\$column\\$}*' . len(split(fline, spl)), '')
                                  else
                                    let spl = ''
                                  endif
                                  let items = emmet#parseIntoTree(query, type).child
                                  let itemno = 0
                                  for item in items
                                    let inner = emmet#toString(item, type, 0, filters, 0, indent)
                                    let inner = substitute(inner, '\$#', '$line'.(itemno*(a:lastline - a:firstline + 1)/len(items)+1).'$', 'g')
                                    let expand .= inner
                                    let itemno = itemno + 1
                                  endfor
                                  if emmet#useFilter(filters, 'e')
                                    let expand = substitute(expand, '&', '\&amp;', 'g')
                                    let expand = substitute(expand, '<', '\&lt;', 'g')
                                    let expand = substitute(expand, '>', '\&gt;', 'g')
                                  endif
                                  let line = getline(a:firstline)
                                  let part = substitute(line, '^\s*', '', '')
                                  for n in range(a:firstline, a:lastline)
                                    let lline = getline(n)
                                    let lpart = substitute(lline, '^\s\+', '', '')
                                    if emmet#useFilter(filters, 't')
                                      let lpart = substitute(lpart, '^[0-9.-]\+\s\+', '', '')
                                      let lpart = substitute(lpart, '\s\+$', '', '')
                                    endif
                                    if emmet#useFilter(filters, '/')
                                      for column in split(lpart, spl)
                                        let expand = substitute(expand, '\$column\$', '\=column', '')
                                      endfor
                                    else
                                      let expand = substitute(expand, '\$line'.(n-a:firstline+1).'\$', '\=lpart', 'g')
                                    endif
                                  endfor
                                  let expand = substitute(expand, '\$line\d*\$', '', 'g')
                                  let expand = substitute(expand, '\$column\$', '', 'g')
                                  let content = join(getline(a:firstline, a:lastline), "\n")
                                  if stridx(expand, '$#') < len(expand)-2
                                    let expand = substitute(expand, '^\(.*\)\$#\s*$', '\1', '')
                                  endif
                                  let expand = substitute(expand, '\$#', '\=content', 'g')
                                else
                                  let str = ''
                                  if visualmode() ==# 'V'
                                    let line = getline(a:firstline)
                                    let lspaces = matchstr(line, '^\s*', '', '')
                                    let part = substitute(line, '^\s*', '', '')
                                    for n in range(a:firstline, a:lastline)
                                      if len(leader) > 0
                                        let line = getline(a:firstline)
                                        let spaces = matchstr(line, '^\s*', '', '')
                                        if len(spaces) >= len(lspaces)
                                          let str .= indent . getline(n)[len(lspaces):] . "\n"
                                        else
                                          let str .= getline(n) . "\n"
                                        endif
                                      else
                                        let lpart = substitute(getline(n), '^\s*', '', '')
                                        let str .= lpart . "\n"
                                      endif
                                    endfor
                                    if stridx(leader, '{$#}') ==# -1
                                      let leader .= '{$#}'
                                    endif
                                    let items = emmet#parseIntoTree(leader, type).child
                                  else
                                    let save_regcont = @"
                                    let save_regtype = getregtype('"')
                                    silent! normal! gvygv
                                    let str = @"
                                    call setreg('"', save_regcont, save_regtype)
                                    if stridx(leader, '{$#}') ==# -1
                                      let leader .= '{$#}'
                                    endif
                                    let items = emmet#parseIntoTree(leader, type).child
                                  endif
                                  for item in items
                                    let expand .= emmet#toString(item, type, 0, filters, 0, '')
                                  endfor
                                  if emmet#useFilter(filters, 'e')
                                    let expand = substitute(expand, '&', '\&amp;', 'g')
                                    let expand = substitute(expand, '<', '\&lt;', 'g')
                                    let expand = substitute(expand, '>', '\&gt;', 'g')
                                  endif
                                  if stridx(leader, '{$#}') !=# -1
                                    let expand = substitute(expand, '\$#', '\="\n" . str', 'g')
                                  endif
                                endif
    1              0.000001   elseif a:mode ==# 4
                                let line = getline('.')
                                let spaces = matchstr(line, '^\s*')
                                if line !~# '^\s*$'
                                  put =spaces.a:abbr
                                else
                                  call setline('.', spaces.a:abbr)
                                endif
                                normal! $
                                call emmet#expandAbbr(0, '')
                                return ''
    1              0.000001   else
    1              0.000003     let line = getline('.')
    1              0.000003     if col('.') < len(line)
                                  let line = matchstr(line, '^\(.*\%'.col('.').'c\)')
    1              0.000001     endif
    1              0.000001     if a:mode ==# 1
                                  let part = matchstr(line, '\([a-zA-Z0-9:_\-\@|]\+\)$')
    1              0.000001     else
    1              0.000012       let part = matchstr(line, '\(\S.*\)$')
    1   0.000015   0.000007       let ftype = emmet#lang#exists(type) ? type : 'html'
    1   0.000884   0.000070       let part = emmet#lang#{ftype}#findTokens(part)
    1              0.000007       let line = line[0: strridx(line, part) + len(part) - 1]
    1              0.000001     endif
    1              0.000003     if col('.') ==# col('$')
    1              0.000002       let rest = ''
                                else
                                  let rest = getline('.')[len(line):]
    1              0.000000     endif
    1              0.000002     let str = part
    1              0.000008     if str =~# s:filtermx
                                  let filters = split(matchstr(str, s:filtermx)[1:], '\s*,\s*')
                                  let str = substitute(str, s:filtermx, '', '')
    1              0.000000     endif
    1   0.006729   0.000013     let items = emmet#parseIntoTree(str, type).child
    2              0.000003     for item in items
    1   0.001246   0.000019       let expand .= emmet#toString(item, type, 0, filters, 0, indent)
    2              0.000002     endfor
    1   0.000023   0.000006     if emmet#useFilter(filters, 'e')
                                  let expand = substitute(expand, '&', '\&amp;', 'g')
                                  let expand = substitute(expand, '<', '\&lt;', 'g')
                                  let expand = substitute(expand, '>', '\&gt;', 'g')
    1              0.000001     endif
    1              0.000007     let expand = substitute(expand, '\$line\([0-9]\+\)\$', '\=submatch(1)', 'g')
    1              0.000001   endif
    1   0.000326   0.000007   let expand = emmet#expandDollarExpr(expand)
    1   0.000051   0.000009   let expand = emmet#expandCursorExpr(expand, a:mode)
    1              0.000001   if len(expand)
    1              0.000004     if has_key(s:emmet_settings, 'timezone') && len(s:emmet_settings.timezone)
                                  let expand = substitute(expand, '${datetime}', strftime('%Y-%m-%dT%H:%M:%S') . s:emmet_settings.timezone, 'g')
    1              0.000001     else
                                  " TODO: on windows, %z/%Z is 'Tokyo(Standard)'
    1              0.000024       let expand = substitute(expand, '${datetime}', strftime('%Y-%m-%dT%H:%M:%S %z'), 'g')
    1              0.000001     endif
    1   0.000016   0.000010     let expand = emmet#unescapeDollarExpr(expand)
    1              0.000002     if a:mode ==# 2 && visualmode() ==# 'v'
                                  if a:firstline ==# a:lastline
                                    let expand = substitute(expand, '[\r\n]\s*', '', 'g')
                                  else
                                    let expand = substitute(expand, '[\n]$', '', 'g')
                                  endif
                                  silent! normal! gv
                                  let col = col('''<')
                                  silent! normal! c
                                  let line = getline('.')
                                  let lhs = matchstr(line, '.*\%<'.col.'c.')
                                  let rhs = matchstr(line, '\%>'.(col-1).'c.*')
                                  let expand = lhs.expand.rhs
                                  let lines = split(expand, '\n')
                                  call setline(line('.'), lines[0])
                                  if len(lines) > 1
                                    call append(line('.'), lines[1:])
                                  endif
    1              0.000000     else
    1              0.000009       if line[:-len(part)-1] =~# '^\s\+$'
    1              0.000004         let indent = line[:-len(part)-1]
                                  else
                                    let indent = ''
    1              0.000001       endif
    1              0.000008       let expand = substitute(expand, '[\r\n]\s*$', '', 'g')
    1   0.000026   0.000009       if emmet#useFilter(filters, 's')
                                    let epart = substitute(expand, '[\r\n]\s*', '', 'g')
    1              0.000001       else
    1              0.000008         let epart = substitute(expand, '[\r\n]', "\n" . indent, 'g')
    1              0.000001       endif
    1              0.000004       let expand = line[:-len(part)-1] . epart . rest
    1              0.000007       let lines = split(expand, '[\r\n]', 1)
    1              0.000002       if a:mode ==# 2
                                    silent! exe 'normal! gvc'
    1              0.000001       endif
    1              0.000010       call setline('.', lines[0])
    1              0.000002       if len(lines) > 1
                                    call append('.', lines[1:])
    1              0.000000       endif
    1              0.000001     endif
    1              0.000001   endif
    1              0.000001   if g:emmet_debug > 1
                                call getchar()
    1              0.000001   endif
    1              0.000009   if search('\ze\$\(cursor\|select\)\$', 'c')
    1              0.000002     let oldselection = &selection
    1              0.000006     let &selection = 'inclusive'
    1              0.000003     if foldclosed(line('.')) !=# -1
                                  silent! foldopen
    1              0.000000     endif
    1   0.000022   0.000010     let pos = emmet#util#getcurpos()
    1   0.000140   0.000008     let use_selection = emmet#getResource(type, 'use_selection', 0)
    1              0.000001     try
    1              0.000002       let l:gdefault = &gdefault
    1              0.000004       let &gdefault = 0
    1              0.000003       if use_selection && getline('.')[col('.')-1:] =~# '^\$select'
                                    let pos[2] += 1
                                    silent! s/\$select\$//
                                    let next = searchpos('.\ze\$select\$', 'nW')
                                    silent! %s/\$\(cursor\|select\)\$//g
                                    call emmet#util#selectRegion([pos[1:2], next])
                                    return "\<esc>gv"
    1              0.000001       else
    1              0.000037         silent! %s/\$\(cursor\|select\)\$//g
    1              0.000004         silent! call setpos('.', pos)
    1              0.000003         if col('.') < col('$')
    1              0.000004           return "\<right>"
                                    endif
                                  endif
    1              0.000002     finally
    1              0.000003       let &gdefault = l:gdefault
    1              0.000001     endtry
                                let &selection = oldselection
                              endif
                              return ''

FUNCTION  <SNR>207_CheckTag()
    Defined: /usr/share/vim/vim81/indent/html.vim line 307
Called 1 time
Total time:   0.000345
 Self time:   0.000195

count  total (s)   self (s)
                              "{{{
                              " Returns an empty string or "SCRIPT".
                              " a:itag can be "tag" or "/tag" or "<!--" or "-->"
    1   0.000127   0.000046   if (s:CheckCustomTag(a:itag))
                                return ""
    1              0.000004   endif
    1   0.000104   0.000035   let ind = s:get_tag(a:itag)
    1              0.000005   if ind == -1
                                " closing tag
                                if s:block != 0
                                  " ignore itag within a block
                                  return ""
                                endif
                                if s:nextrel == 0
                                  let s:curind -= 1
                                else
                                  let s:nextrel -= 1
                                endif
    1              0.000005   elseif ind == 1
                                " opening tag
    1              0.000005     if s:block != 0
                                  return ""
    1              0.000002     endif
    1              0.000008     let s:nextrel += 1
                              elseif ind != 0
                                " block-tag (opening or closing)
                                return s:CheckBlockTag(a:itag, ind)
                              " else ind==0 (other tag found): keep indent
    1              0.000003   endif
    1              0.000005   return ""

FUNCTION  <SNR>99_clear_matches()
    Defined: ~/.vim/bundle/vim-css-color/autoload/css_color.vim line 183
Called 27 times
Total time:   0.000651
 Self time:   0.000651

count  total (s)   self (s)
   27              0.000258 	if exists('w:color_match_id')
                            		call filter(w:color_match_id, 'matchdelete(v:val)')
                            		unlet w:color_match_id
   27              0.000053 	endif

FUNCTION  ctrlp#mrufiles#cachefile()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim line 137
Called 1 time
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    1              0.000027 	if !exists('s:cadir') || !exists('s:cafile')
                            		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
                            		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
    1              0.000004 	en
    1              0.000008 	retu s:cafile

FUNCTION  emmet#util#getcurpos()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet/util.vim line 339
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000003   let pos = getpos('.')
    1              0.000004   if mode(0) ==# 'i' && pos[2] > 0
    1              0.000002     let pos[2] -=1
    1              0.000000   endif
    1              0.000002   return pos

FUNCTION  emmet#getResource()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet.vim line 310
Called 14 times
Total time:   0.005726
 Self time:   0.001313

count  total (s)   self (s)
   14              0.000051   if exists('b:emmet_' . a:name)
                                return get(b:, 'emmet_' . a:name)
   14              0.000007   endif
   14              0.000024   let global = {}
   14              0.000051   if has_key(s:emmet_settings, '*') && has_key(s:emmet_settings['*'], a:name)
                                let global = extend(global, s:emmet_settings['*'][a:name])
   14              0.000009   endif
                            
   14              0.000031   if has_key(s:emmet_settings, a:type)
   14              0.000027     let types = [a:type]
                              else
                                let types = split(a:type, '\.')
   14              0.000008   endif
                            
   18              0.000030   for type in types
   14              0.000036     if !has_key(s:emmet_settings, type)
                                  continue
   14              0.000006     endif
   14              0.000021     let ret = a:default
                            
   14              0.000035     if has_key(s:emmet_settings[type], 'extends')
                                  let extends = s:emmet_settings[type].extends
                                  if type(extends) ==# 1
                                    let tmp = split(extends, '\s*,\s*')
                                    unlet! extends
                                    let extends = tmp
                                  endif
                                  for ext in extends
                                    if has_key(s:emmet_settings, ext) && has_key(s:emmet_settings[ext], a:name)
                                      if type(ret) ==# 3 || type(ret) ==# 4
                                        call emmet#mergeConfig(ret, s:emmet_settings[ext][a:name])
                                      else
                                        let ret = s:emmet_settings[ext][a:name]
                                      endif
                                    endif
                                  endfor
   14              0.000004     endif
                            
   14              0.000040     if has_key(s:emmet_settings[type], a:name)
    5              0.000014       if type(ret) ==# 3 || type(ret) ==# 4
    4   0.004453   0.000040         call emmet#mergeConfig(ret, s:emmet_settings[type][a:name])
    4              0.000046         return extend(global, ret)
    1              0.000001       else
    1              0.000003         return s:emmet_settings[type][a:name]
                                  endif
    9              0.000004     endif
    9              0.000017     if !empty(ret)
    5              0.000013       if type(ret) ==# 3 || type(ret) ==# 4
                                    let ret = extend(global, ret)
    5              0.000003       endif
    5              0.000005       return ret
    4              0.000002     endif
    8              0.000010   endfor
                            
    4              0.000006   let ret = a:default
    4              0.000012   if type(ret) ==# 3 || type(ret) ==# 4
    2              0.000004     let ret = extend(global, ret)
    4              0.000003   endif
    4              0.000004   return ret

FUNCTION  emmet#lang#html#findTokens()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet/lang/html.vim line 16
Called 1 time
Total time:   0.000255
 Self time:   0.000255

count  total (s)   self (s)
    1              0.000003   let str = a:str
    1              0.000003   let [pos, last_pos] = [0, 0]
    1              0.000002   while 1
    1              0.000009     let tag = matchstr(str, '<[a-zA-Z].\{-}>', pos)
    1              0.000002     if len(tag) == 0
    1              0.000001       break
                                endif
                                let pos = stridx(str, tag, pos) + len(tag)
    1              0.000001   endwhile
    1              0.000001   while 1
    1              0.000007     let tag = matchstr(str, '{%[^%]\{-}%}', pos)
    1              0.000002     if len(tag) == 0
    1              0.000001       break
                                endif
                                let pos = stridx(str, tag, pos) + len(tag)
    1              0.000001   endwhile
    1              0.000001   let last_pos = pos
    2              0.000004   while len(str) > 0
    2              0.000158     let token = matchstr(str, s:mx, pos)
    2              0.000004     if token ==# ''
    1              0.000001       break
    1              0.000001     endif
    1              0.000004     if token =~# '^\s'
                                  let token = matchstr(token, '^\s*\zs.*')
                                  let last_pos = stridx(str, token, pos)
    1              0.000001     endif
    1              0.000006     let pos = stridx(str, token, pos) + len(token)
    2              0.000003   endwhile
    1              0.000004   let str = a:str[last_pos :-1]
    1              0.000009   if str =~# '^\w\+="[^"]*$'
                                return ''
    1              0.000001   endif
    1              0.000002   return str

FUNCTION  HtmlIndent()
    Defined: /usr/share/vim/vim81/indent/html.vim line 954
Called 1 time
Total time:   0.003425
 Self time:   0.001148

count  total (s)   self (s)
                              "{{{
    1              0.000018   if prevnonblank(v:lnum - 1) < 1
                                " First non-blank line has no indent.
                                return 0
    1              0.000003   endif
                            
    1              0.000021   let curtext = tolower(getline(v:lnum))
    1              0.000011   let indentunit = shiftwidth()
                            
    1              0.000014   let b:hi_newstate = {}
    1              0.000013   let b:hi_newstate.lnum = v:lnum
                            
                              " When syntax HL is enabled, detect we are inside a tag.  Indenting inside
                              " a tag works very differently. Do not do this when the line starts with
                              " "<", it gets the "htmlTag" ID but we are not inside a tag then.
    1              0.000030   if curtext !~ '^\s*<'
    1              0.000030     normal! ^
    1              0.000296     let stack = synstack(v:lnum, col('.'))  " assumes there are no tabs
    1              0.000010     let foundHtmlString = 0
    1              0.000017     for synid in reverse(stack)
                                  let name = synIDattr(synid, "name")
                                  if index(b:hi_insideStringNames, name) >= 0
                                    let foundHtmlString = 1
                                  elseif index(b:hi_insideTagNames, name) >= 0
                                    " Yes, we are inside a tag.
                                    let indent = s:InsideTag(foundHtmlString)
                                    if indent >= 0
                                      " Do not keep the state. TODO: could keep the block type.
                                      let b:hi_indent.lnum = 0
                                      return indent
                                    endif
                                  endif
    1              0.000006     endfor
    1              0.000003   endif
                            
                              " does the line start with a closing tag?
    1              0.000064   let swendtag = match(curtext, '^\s*</') >= 0
                            
    1              0.000027   if prevnonblank(v:lnum - 1) == b:hi_indent.lnum && b:hi_lasttick == b:changedtick - 1
                                " use state (continue from previous line)
    1              0.000004   else
                                " start over (know nothing)
    1   0.002175   0.000047     let b:hi_indent = s:FreshState(v:lnum)
    1              0.000003   endif
                            
    1              0.000008   if b:hi_indent.block >= 2
                                " within block
                                let endtag = s:endtags[b:hi_indent.block]
                                let blockend = stridx(curtext, endtag)
                                if blockend >= 0
                                  " block ends here
                                  let b:hi_newstate.block = 0
                                  " calc indent for REST OF LINE (may start more blocks):
                                  call s:CountTagsAndState(strpart(curtext, blockend + strlen(endtag)))
                                  if swendtag && b:hi_indent.block != 5
                                    let indent = b:hi_indent.blocktagind + s:curind * indentunit
                                    let b:hi_newstate.baseindent = indent + s:nextrel * indentunit
                                  else
                                    let indent = s:Alien{b:hi_indent.block}()
                                    let b:hi_newstate.baseindent = b:hi_indent.blocktagind + s:nextrel * indentunit
                                  endif
                                else
                                  " block continues
                                  " indent this line with alien method
                                  let indent = s:Alien{b:hi_indent.block}()
                                endif
    1              0.000003   else
                                " not within a block - within usual html
    1              0.000012     let b:hi_newstate.block = b:hi_indent.block
    1              0.000005     if swendtag
                                  " The current line starts with an end tag, align with its start tag.
                                  call cursor(v:lnum, 1)
                                  let start_lnum = HtmlIndent_FindStartTag()
                                  if start_lnum > 0
                                    " check for the line starting with something inside a tag:
                                    " <sometag               <- align here
                                    "    attr=val><open>     not here
                                    let text = getline(start_lnum)
                                    let angle = matchstr(text, '[<>]')
                                    if angle == '>'
                                      call cursor(start_lnum, 1)
                                      normal! f>%
                                      let start_lnum = line('.')
                                      let text = getline(start_lnum)
                                    endif
                            
                                    let indent = indent(start_lnum)
                                    if col('.') > 2
                                      let swendtag = match(text, '^\s*</') >= 0
                                      call s:CountITags(text[: col('.') - 2])
                                      let indent += s:nextrel * shiftwidth()
                                      if !swendtag
                                        let indent += s:curind * shiftwidth()
                                      endif
                                    endif
                                  else
                                    " not sure what to do
                                    let indent = b:hi_indent.baseindent
                                  endif
                                  let b:hi_newstate.baseindent = indent
    1              0.000004     else
    1   0.000187   0.000038       call s:CountTagsAndState(curtext)
    1              0.000009       let indent = b:hi_indent.baseindent
    1              0.000020       let b:hi_newstate.baseindent = indent + (s:curind + s:nextrel) * indentunit
    1              0.000004     endif
    1              0.000003   endif
                            
    1              0.000009   let b:hi_lasttick = b:changedtick
    1              0.000017   call extend(b:hi_indent, b:hi_newstate, "force")
    1              0.000006   return indent

FUNCTION  emmet#getFilters()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet.vim line 305
Called 1 time
Total time:   0.000148
 Self time:   0.000015

count  total (s)   self (s)
    1   0.000142   0.000009   let filterstr = emmet#getResource(a:type, 'filters', '')
    1              0.000006   return split(filterstr, '\s*,\s*')

FUNCTION  emmet#parseIntoTree()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet.vim line 102
Called 1 time
Total time:   0.006716
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000002   let abbr = a:abbr
    1              0.000001   let type = a:type
    1   0.006712   0.000032   return emmet#lang#{emmet#lang#type(type)}#parseIntoTree(abbr, type)

FUNCTION  <SNR>30_savetofile()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim line 88
Called 1 time
Total time:   0.028006
 Self time:   0.000041

count  total (s)   self (s)
    1   0.028004   0.000039 	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)

FUNCTION  emmet#reExpandDollarExpr()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet.vim line 466
Called 1 time
Total time:   0.000309
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000002   let expand = a:expand
    1   0.000289   0.000008   let dollar_exprs = emmet#getDollarExprs(expand)
    1              0.000002   if len(dollar_exprs) > 0
                                if a:times < 9
                                  for n in range(len(dollar_exprs))
                                    let pair = get(dollar_exprs, n)
                                    let pat = get(pair, 'expr')
                                    let sub = get(pair, 'value')
                                    let expand = substitute(expand, pat, sub, '')
                                  endfor
                                  return emmet#reExpandDollarExpr(expand, a:times + 1)
                                endif
    1              0.000001   endif
    1              0.000001   return expand

FUNCTION  emmet#toString()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet.vim line 199
Called 1 time
Total time:   0.001227
 Self time:   0.000250

count  total (s)   self (s)
    1              0.000002   let current = a:1
    1              0.000001   if a:0 > 1
    1              0.000002     let type = a:2
                              else
                                let type = &filetype
    1              0.000000   endif
    1              0.000004   if len(type) ==# 0 | let type = 'html' | endif
    1              0.000001   if a:0 > 2
    1              0.000002     let inline = a:3
                              else
                                let inline = 0
    1              0.000001   endif
    1              0.000001   if a:0 > 3
    1              0.000002     if type(a:4) ==# 1
                                  let filters = split(a:4, '\s*,\s*')
    1              0.000001     else
    1              0.000001       let filters = a:4
    1              0.000001     endif
                              else
                                let filters = ['html']
    1              0.000001   endif
    1              0.000001   if a:0 > 4
    1              0.000001     let group_itemno = a:5
                              else
                                let group_itemno = 0
    1              0.000001   endif
    1              0.000001   if a:0 > 5
    1              0.000001     let indent = a:6
                              else
                                let indent = ''
    1              0.000001   endif
                            
    1   0.000085   0.000007   let dollar_expr = emmet#getResource(type, 'dollar_expr', 1)
    1              0.000002   let itemno = 0
    1              0.000001   let str = ''
    1   0.000045   0.000012   let rtype = emmet#lang#type(type)
    2              0.000004   while itemno < current.multiplier
    1              0.000001     if len(current.name)
    1              0.000001       if current.multiplier ==# 1
    1   0.000886   0.000020         let inner = emmet#lang#{rtype}#toString(s:emmet_settings, current, type, inline, filters, s:itemno(group_itemno, current), indent)
                                  else
                                    let inner = emmet#lang#{rtype}#toString(s:emmet_settings, current, type, inline, filters, s:itemno(itemno, current), indent)
    1              0.000001       endif
    1              0.000001       if current.multiplier > 1
                                    let inner = substitute(inner, '\$#', '$line'.(itemno+1).'$', 'g')
    1              0.000000       endif
    1              0.000003       let str .= inner
                                else
                                  let snippet = current.snippet
                                  if len(snippet) ==# 0
                                    let snippets = emmet#getResource(type, 'snippets', {})
                                    if !empty(snippets) && has_key(snippets, 'emmet_snippet')
                                      let snippet = snippets['emmet_snippet']
                                    endif
                                  endif
                                  if len(snippet) > 0
                                    let tmp = snippet
                                    let tmp = substitute(tmp, '\${emmet_name}', current.name, 'g')
                                    let snippet_node = emmet#newNode()
                                    let snippet_node.value = '{'.tmp.'}'
                                    let snippet_node.important = current.important
                                    let snippet_node.multiplier = current.multiplier
                                    let str .= emmet#lang#{rtype}#toString(s:emmet_settings, snippet_node, type, inline, filters, s:itemno(group_itemno, current), indent)
                                    if current.multiplier > 1
                                      let str .= "\n"
                                    endif
                                  else
                                    if len(current.name)
                                      let str .= current.name
                                    endif
                                    if len(current.value)
                                      let text = current.value[1:-2]
                                      if dollar_expr
                                        " TODO: regexp engine specified
                                        if exists('&regexpengine')
                                          let text = substitute(text, '\%#=1\%(\\\)\@\<!\(\$\+\)\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d", max([itemno, group_itemno])+1).submatch(2)', 'g')
                                        else
                                          let text = substitute(text, '\%(\\\)\@\<!\(\$\+\)\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d", max([itemno, group_itemno])+1).submatch(2)', 'g')
                                        endif
                                        let text = substitute(text, '\${nr}', "\n", 'g')
                                        let text = substitute(text, '\\\$', '$', 'g')
                                      endif
                                      let str .= text
                                    endif
                                  endif
                                  let inner = ''
                                  if len(current.child)
                                    for n in current.child
                                      let inner .= emmet#toString(n, type, inline, filters, s:itemno(group_itemno, n), indent)
                                    endfor
                                  else
                                    let inner = current.value[1:-2]
                                  endif
                                  let inner = substitute(inner, "\n", "\n" . indent, 'g')
                                  let str = substitute(str, '\${child}', inner, '')
    1              0.000001     endif
    1              0.000002     let itemno = itemno + 1
    2              0.000002   endwhile
    1              0.000002   return str

FUNCTION  emmet#getDollarExprs()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet.vim line 417
Called 1 time
Total time:   0.000281
 Self time:   0.000124

count  total (s)   self (s)
    1              0.000002   let expand = a:expand
    1              0.000002   let dollar_list = []
    1              0.000002   let dollar_reg = '\%(\\\)\@<!\${\(\([^{}]\|\%(\\\)\@\<=[{}]\)\{}\)}'
    2              0.000002   while 1
    2              0.000038     let matcharr = matchlist(expand, dollar_reg)
    2              0.000005     if len(matcharr) > 0
    1              0.000002       let key = get(matcharr, 1)
    1              0.000003       if key !~# '^\d\+:'
    1              0.000004         let key = substitute(key, '\\{', '{', 'g')
    1              0.000003         let key = substitute(key, '\\}', '}', 'g')
    1   0.000164   0.000007         let value = emmet#getDollarValueByKey(key)
    1              0.000003         if type(value) ==# type('')
                                      let expr = get(matcharr, 0)
                                      call add(dollar_list, {'expr': expr, 'value': value})
    1              0.000001         endif
    1              0.000001       endif
    1              0.000000     else
    1              0.000001       break
    1              0.000000     endif
    1              0.000018     let expand = substitute(expand, dollar_reg, '', '')
    2              0.000003   endwhile
    1              0.000001   return dollar_list

FUNCTION  emmet#lang#html#toString()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet/lang/html.vim line 437
Called 1 time
Total time:   0.000859
 Self time:   0.000373

count  total (s)   self (s)
    1              0.000002   let settings = a:settings
    1              0.000002   let current = a:current
    1              0.000001   let type = a:type
    1              0.000002   let inline = a:inline
    1              0.000002   let filters = a:filters
    1              0.000001   let itemno = a:itemno
    1              0.000002   let indent = a:indent
    1   0.000085   0.000007   let dollar_expr = emmet#getResource(type, 'dollar_expr', 1)
    1   0.000083   0.000007   let q = emmet#getResource(type, 'quote_char', '"')
    1   0.000086   0.000011   let ct = emmet#getResource(type, 'comment_type', 'both')
    1   0.000136   0.000007   let an = emmet#getResource(type, 'attribute_name', {})
    1   0.000076   0.000009   let empty_element_suffix = emmet#getResource(type, 'empty_element_suffix', settings.html.empty_element_suffix)
                            
    1   0.000022   0.000006   if emmet#useFilter(filters, 'haml')
                                return emmet#lang#haml#toString(settings, current, type, inline, filters, itemno, indent)
    1              0.000000   endif
    1   0.000025   0.000009   if emmet#useFilter(filters, 'slim')
                                return emmet#lang#slim#toString(settings, current, type, inline, filters, itemno, indent)
    1              0.000001   endif
                            
    1              0.000002   let comment = ''
    1              0.000002   let current_name = current.name
    1              0.000001   if dollar_expr
    1              0.000007     let current_name = substitute(current_name, '\$$', itemno+1, '')
    1              0.000001   endif
                            
    1              0.000002   let str = ''
    1              0.000002   if len(current_name) == 0
                                let text = current.value[1:-2]
                                if dollar_expr
                                  " TODO: regexp engine specified
                                  let nr = itemno + 1
                                  if exists('&regexpengine')
                                    let text = substitute(text, '\%#=1\%(\\\)\@\<!\(\$\+\)\(@-\?[0-9]\+\)\{0,1}\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d",s:dollar_add(submatch(2)[1:],nr)).submatch(3)', 'g')
                                  else
                                    let text = substitute(text, '\%(\\\)\@\<!\(\$\+\)\(@-\?[0-9]\+\)\{0,1}\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d",s:dollar_add(submatch(2)[1:],nr).submatch(3)', 'g')
                                  endif
                                  let text = substitute(text, '\${nr}', "\n", 'g')
                                  let text = substitute(text, '\\\$', '$', 'g')
                                endif
                                return text
    1              0.000001   endif
    1              0.000002   if len(current_name) > 0
    1              0.000002     let str .= '<' . current_name
    1              0.000001   endif
    3   0.000040   0.000011   for attr in emmet#util#unique(current.attrs_order + keys(current.attr))
    2              0.000004     if !has_key(current.attr, attr)
    2              0.000002       continue
                                endif
                                let Val = current.attr[attr]
                                if type(Val) == 2 && Val == function('emmet#types#true')
                                  unlet Val
                                  let Val = 'true'
                                  if g:emmet_html5
                                    let str .= ' ' . attr
                                  else
                                    let str .= ' ' . attr . '=' . q . attr . q
                                  endif
                                  if emmet#useFilter(filters, 'c')
                                    if attr ==# 'id' | let comment .= '#' . Val | endif
                                    if attr ==# 'class' | let comment .= '.' . Val | endif
                                  endif
                                else
                                  if dollar_expr
                                    while Val =~# '\$\([^#{]\|$\)'
                                      " TODO: regexp engine specified
                                      if exists('&regexpengine')
                                        let Val = substitute(Val, '\%#=1\(\$\+\)\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d", itemno+1).submatch(2)', 'g')
                                      else
                                        let Val = substitute(Val, '\(\$\+\)\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d", itemno+1).submatch(2)', 'g')
                                      endif
                                    endwhile
                                    let attr = substitute(attr, '\$$', itemno+1, '')
                                  endif
                                  if attr ==# 'class' && emmet#useFilter(filters, 'bem')
                                    let vals = split(Val, '\s\+')
                                    let Val = ''
                                    let lead = ''
                                    for _val in vals
                                      if len(Val) > 0
                                        let Val .= ' '
                                      endif
                                      if _val =~# '^_'
                                        if has_key(current.parent.attr, 'class')
                                          let lead = current.parent.attr["class"]
                                          if _val =~# '^__'
                                            let Val .= lead . _val
                                          else
                                            let Val .= lead . ' ' . lead . _val
                                          endif
                                        else
                                          let lead = split(vals[0], '_')[0]
                                          let Val .= lead . _val
                                        endif
                                      elseif _val =~# '^-'
                                        for l in split(_val, '_')
                                          if len(Val) > 0
                                            let Val .= ' '
                                          endif
                                          let l = substitute(l, '^-', '__', '')
                                          if len(lead) == 0
                                            let pattr = current.parent.attr
                                            if has_key(pattr, 'class')
                                              let lead = split(pattr['class'], '\s\+')[0]
                                            endif
                                          endif
                                          let Val .= lead . l
                                          let lead .= l . '_'
                                        endfor
                                      else
                                        let Val .= _val
                                      endif
                                    endfor
                                  endif
                                  if has_key(an, attr)
                                    let attr = an[attr]
                                  endif
                                  if emmet#isExtends(type, 'jsx') && Val =~ '^{.*}$'
                                    let str .= ' ' . attr . '=' . Val
                                  else
                                    let str .= ' ' . attr . '=' . q . Val . q
                                  endif
                                  if emmet#useFilter(filters, 'c')
                                    if attr ==# 'id' | let comment .= '#' . Val | endif
                                    if attr ==# 'class' | let comment .= '.' . Val | endif
                                  endif
                                endif
                                unlet Val
    1              0.000002   endfor
    1              0.000002   if len(comment) > 0 && ct ==# 'both'
                                let str = '<!-- ' . comment . " -->\n" . str
    1              0.000000   endif
    1              0.000001   if current.empty
                                let str .= ' />'
    1              0.000004   elseif stridx(','.settings.html.empty_elements.',', ','.current_name.',') != -1
                                let str .= empty_element_suffix
    1              0.000001   else
    1              0.000001     let str .= '>'
    1              0.000003     let text = current.value[1:-2]
    1              0.000001     if dollar_expr
                                  " TODO: regexp engine specified
    1              0.000002       let nr = itemno + 1
    1              0.000003       if exists('&regexpengine')
    1              0.000019         let text = substitute(text, '\%#=1\%(\\\)\@\<!\(\$\+\)\(@-\?[0-9]\+\)\{0,1}\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d",s:dollar_add(submatch(2)[1:],nr)).submatch(3)', 'g')
                                  else
                                    let text = substitute(text, '\%(\\\)\@\<!\(\$\+\)\(@-\?[0-9]\+\)\{0,1}\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d",s:dollar_add(submatch(2)[1:],nr)).submatch(3)', 'g')
    1              0.000000       endif
    1              0.000007       let text = substitute(text, '\${nr}', "\n", 'g')
    1              0.000004       let text = substitute(text, '\\\$', '$', 'g')
    1              0.000002       if text != ''
                                    let str = substitute(str, '\("\zs$#\ze"\|\s\zs\$#"\|"\$#\ze\s\)', text, 'g')
    1              0.000000       endif
    1              0.000001     endif
    1              0.000002     let str .= text
    1              0.000002     let nc = len(current.child)
    1              0.000001     let dr = 0
    1              0.000001     if nc > 0
                                  for n in range(nc)
                                    let child = current.child[n]
                                    if child.multiplier > 1 || (child.multiplier == 1 && len(child.child) > 0 && stridx(','.settings.html.inline_elements.',', ','.current_name.',') == -1) || settings.html.block_all_childless
                                      let str .= "\n" . indent
                                      let dr = 1
                                    elseif len(current_name) > 0 && stridx(','.settings.html.inline_elements.',', ','.current_name.',') == -1
                                      if nc > 1 || (len(child.name) > 0 && stridx(','.settings.html.inline_elements.',', ','.child.name.',') == -1)
                                        let str .= "\n" . indent
                                        let dr = 1
                                      elseif current.multiplier == 1 && nc == 1 && len(child.name) == 0
                                        let str .= "\n" . indent
                                        let dr = 1
                                      endif
                                    endif
                                    let inner = emmet#toString(child, type, 0, filters, itemno, indent)
                                    let inner = substitute(inner, "^\n", '', 'g')
                                    let inner = substitute(inner, "\n", "\n" . escape(indent, '\'), 'g')
                                    let inner = substitute(inner, "\n" . escape(indent, '\') . '$', '', 'g')
                                    let str .= inner
                                  endfor
    1              0.000001     else
    1              0.000005       if settings.html.indent_blockelement && len(current_name) > 0 && stridx(','.settings.html.inline_elements.',', ','.current_name.',') == -1 || settings.html.block_all_childless
                                    let str .= "\n" . indent . '${cursor}' . "\n"
    1              0.000000       else
    1              0.000002         let str .= '${cursor}'
    1              0.000001       endif
    1              0.000001     endif
    1              0.000000     if dr
                                  let str .= "\n"
    1              0.000001     endif
    1              0.000002     let str .= '</' . current_name . '>'
    1              0.000000   endif
    1              0.000002   if len(comment) > 0
                                if ct ==# 'lastonly'
                                  let str .= '<!-- ' . comment . ' -->'
                                else
                                  let str .= "\n<!-- /" . comment . ' -->'
                                endif
    1              0.000001   endif
    1              0.000004   if len(current_name) > 0 && current.multiplier > 0 || stridx(','.settings.html.block_elements.',', ','.current_name.',') != -1
    1              0.000002     let str .= "\n"
    1              0.000001   endif
    1              0.000001   return str

FUNCTION  <SNR>207_FreshState()
    Defined: /usr/share/vim/vim81/indent/html.vim line 410
Called 1 time
Total time:   0.002128
 Self time:   0.001411

count  total (s)   self (s)
                              "{{{
                              " A state is to know ALL relevant details about the
                              " lines 1..a:lnum-1, initial calculating (here!) can be slow, but updating is
                              " fast (incremental).
                              " TODO: this should be split up in detecting the block type and computing the
                              " indent for the block type, so that when we do not know the indent we do
                              " not need to clear the whole state and re-detect the block type again.
                              " State:
                              "	lnum		last indented line == prevnonblank(a:lnum - 1)
                              "	block = 0	a:lnum located within special tag: 0:none, 2:<pre>,
                              "			3:<script>, 4:<style>, 5:<!--, 6:<!--[
                              "	baseindent	use this indent for line a:lnum as a start - kind of
                              "			autoindent (if block==0)
                              "	scripttype = ''	type attribute of a script tag (if block==3)
                              "	blocktagind	indent for current opening (get) and closing (set)
                              "			blocktag (if block!=0)
                              "	blocklnr	lnum of starting blocktag (if block!=0)
                              "	inattr		line {lnum} starts with attributes of a tag
    1              0.000008   let state = {}
    1              0.000018   let state.lnum = prevnonblank(a:lnum - 1)
    1              0.000009   let state.scripttype = ""
    1              0.000008   let state.blocktagind = -1
    1              0.000006   let state.block = 0
    1              0.000008   let state.baseindent = 0
    1              0.000007   let state.blocklnr = 0
    1              0.000007   let state.inattr = 0
                            
    1              0.000007   if state.lnum == 0
                                return state
    1              0.000003   endif
                            
                              " Heuristic:
                              " remember startline state.lnum
                              " look back for <pre, </pre, <script, </script, <style, </style tags
                              " remember stopline
                              " if opening tag found,
                              "	assume a:lnum within block
                              " else
                              "	look back in result range (stopline, startline) for comment
                              "	    \ delimiters (<!--, -->)
                              "	if comment opener found,
                              "	    assume a:lnum within comment
                              "	else
                              "	    assume usual html for a:lnum
                              "	    if a:lnum-1 has a closing comment
                              "		look back to get indent of comment opener
                              " FI
                            
                              " look back for a blocktag
    1              0.000011   let stopline2 = v:lnum + 1
    1              0.000015   if has_key(b:hi_indent, 'block') && b:hi_indent.block > 5
                                let [stopline2, stopcol2] = searchpos('<!--', 'bnW')
    1              0.000003   endif
    1              0.000068   let [stopline, stopcol] = searchpos('\c<\zs\/\=\%(pre\>\|script\>\|style\>\)', "bnW")
    1              0.000010   if stopline > 0 && stopline < stopline2
                                " ugly ... why isn't there searchstr()
                                let tagline = tolower(getline(stopline))
                                let blocktag = matchstr(tagline, '\/\=\%(pre\>\|script\>\|style\>\)', stopcol - 1)
                                if blocktag[0] != "/"
                                  " opening tag found, assume a:lnum within block
                                  let state.block = s:indent_tags[blocktag]
                                  if state.block == 3
                                    let state.scripttype = s:GetScriptType(matchstr(tagline, '\>[^>]*', stopcol))
                                  endif
                                  let state.blocklnr = stopline
                                  " check preceding tags in the line:
                                  call s:CountITags(tagline[: stopcol-2])
                                  let state.blocktagind = indent(stopline) + (s:curind + s:nextrel) * shiftwidth()
                                  return state
                                elseif stopline == state.lnum
                                  " handle special case: previous line (= state.lnum) contains a
                                  " closing blocktag which is preceded by line-noise;
                                  " blocktag == "/..."
                                  let swendtag = match(tagline, '^\s*</') >= 0
                                  if !swendtag
                                    let [bline, bcol] = searchpos('<'.blocktag[1:].'\>', "bnW")
                                    call s:CountITags(tolower(getline(bline)[: bcol-2]))
                                    let state.baseindent = indent(bline) + (s:curind + s:nextrel) * shiftwidth()
                                    return state
                                  endif
                                endif
    1              0.000002   endif
    1              0.000007   if stopline > stopline2
                                let stopline = stopline2
                                let stopcol = stopcol2
    1              0.000002   endif
                            
                              " else look back for comment
    1              0.000363   let [comlnum, comcol, found] = searchpos('\(<!--\[\)\|\(<!--\)\|-->', 'bpnW', stopline)
    1              0.000009   if found == 2 || found == 3
                                " comment opener found, assume a:lnum within comment
                                let state.block = (found == 3 ? 5 : 6)
                                let state.blocklnr = comlnum
                                " check preceding tags in the line:
                                call s:CountITags(tolower(getline(comlnum)[: comcol-2]))
                                if found == 2
                                  let state.baseindent = b:hi_indent.baseindent
                                endif
                                let state.blocktagind = indent(comlnum) + (s:curind + s:nextrel) * shiftwidth()
                                return state
    1              0.000003   endif
                            
                              " else within usual HTML
    1              0.000018   let text = tolower(getline(state.lnum))
                            
                              " Check a:lnum-1 for closing comment (we need indent from the opening line).
                              " Not when other tags follow (might be --> inside a string).
    1              0.000013   let comcol = stridx(text, '-->')
    1              0.000011   if comcol >= 0 && match(text, '[<>]', comcol) <= 0
                                call cursor(state.lnum, comcol + 1)
                                let [comlnum, comcol] = searchpos('<!--', 'bW')
                                if comlnum == state.lnum
                                  let text = text[: comcol-2]
                                else
                                  let text = tolower(getline(comlnum)[: comcol-2])
                                endif
                                call s:CountITags(text)
                                let state.baseindent = indent(comlnum) + (s:curind + s:nextrel) * shiftwidth()
                                " TODO check tags that follow "-->"
                                return state
    1              0.000003   endif
                            
                              " Check if the previous line starts with end tag.
    1              0.000033   let swendtag = match(text, '^\s*</') >= 0
                            
                              " If previous line ended in a closing tag, line up with the opening tag.
    1              0.000039   if !swendtag && text =~ '</' . s:tagname . '\s*>\s*$'
                                call cursor(state.lnum, 99999)
                                normal! F<
                                let start_lnum = HtmlIndent_FindStartTag()
                                if start_lnum > 0
                                  let state.baseindent = indent(start_lnum)
                                  if col('.') > 2
                                    " check for tags before the matching opening tag.
                                    let text = getline(start_lnum)
                                    let swendtag = match(text, '^\s*</') >= 0
                                    call s:CountITags(text[: col('.') - 2])
                                    let state.baseindent += s:nextrel * shiftwidth()
                                    if !swendtag
                                      let state.baseindent += s:curind * shiftwidth()
                                    endif
                                  endif
                                  return state
                                endif
    1              0.000002   endif
                            
                              " Else: no comments. Skip backwards to find the tag we're inside.
    1   0.000233   0.000053   let [state.lnum, found] = HtmlIndent_FindTagStart(state.lnum)
                              " Check if that line starts with end tag.
    1              0.000011   let text = getline(state.lnum)
    1              0.000045   let swendtag = match(text, '^\s*</') >= 0
    1   0.000580   0.000043   call s:CountITags(tolower(text))
    1              0.000025   let state.baseindent = indent(state.lnum) + s:nextrel * shiftwidth()
    1              0.000006   if !swendtag
    1              0.000012     let state.baseindent += s:curind * shiftwidth()
    1              0.000003   endif
    1              0.000006   return state

FUNCTION  <SNR>210_itemno()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet.vim line 182
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000002   let current = a:current
    1              0.000002   if current.basedirect > 0
    1              0.000001     if current.basevalue ==# 0
    1              0.000002       return a:itemno
                                else
                                  return current.basevalue - 1 + a:itemno
                                endif
                              else
                                if current.basevalue ==# 0
                                  return current.multiplier - 1 - a:itemno
                                else
                                  return current.multiplier + current.basevalue - 2 - a:itemno
                                endif
                              endif

FUNCTION  emmet#unescapeDollarExpr()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet.vim line 504
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005   return substitute(a:expand, '\\\$', '$', 'g')

FUNCTION  HtmlIndent_FindTagStart()
    Defined: /usr/share/vim/vim81/indent/html.vim line 843
Called 1 time
Total time:   0.000180
 Self time:   0.000180

count  total (s)   self (s)
                              "{{{
                              " Avoids using the indent of a continuation line.
                              " Moves the cursor.
                              " Return two values:
                              " - the matching line number or "lnum".
                              " - a flag indicating whether we found the end of a tag.
                              " This method is global so that HTML-like indenters can use it.
                              " To avoid matching " > " or " < " inside a string require that the opening
                              " "<" is followed by a word character and the closing ">" comes after a
                              " non-white character.
    1              0.000052   let idx = match(getline(a:lnum), '\S>\s*$')
    1              0.000007   if idx > 0
    1              0.000014     call cursor(a:lnum, idx)
    1              0.000073     let lnum = searchpair('<\w', '' , '\S>', 'bW', '', max([a:lnum - b:html_indent_line_limit, 0]))
    1              0.000006     if lnum > 0
    1              0.000008       return [lnum, 1]
                                endif
                              endif
                              return [a:lnum, 0]

FUNCTION  <SNR>30_mergelists()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim line 31
Called 1 time
Total time:   0.000726
 Self time:   0.000388

count  total (s)   self (s)
    1   0.000373   0.000079 	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
    1              0.000248 	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
    1              0.000029 	let mrufs = s:mrufs + diskmrufs
    1   0.000072   0.000028 	retu s:chop(mrufs)

FUNCTION  ctrlp#utils#writecache()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim line 63
Called 1 time
Total time:   0.027965
 Self time:   0.027911

count  total (s)   self (s)
    1   0.000108   0.000054 	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
    1              0.027838 		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
    1              0.000012 	en

FUNCTION  <SNR>43_Highlight_Matching_Pair()
    Defined: /usr/share/vim/vim81/plugin/matchparen.vim line 39
Called 39 times
Total time:   0.108328
 Self time:   0.108328

count  total (s)   self (s)
                              " Remove any previous match.
   39              0.000655   if exists('w:paren_hl_on') && w:paren_hl_on
   27              0.000246     silent! call matchdelete(3)
   27              0.000171     let w:paren_hl_on = 0
   39              0.000101   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   39              0.000476   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   39              0.000073   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   39              0.000330   let c_lnum = line('.')
   39              0.000261   let c_col = col('.')
   39              0.000147   let before = 0
                            
   39              0.000295   let text = getline(c_lnum)
   39              0.002078   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   39              0.000273   if empty(matches)
                                let [c_before, c] = ['', '']
   39              0.000092   else
   39              0.000777     let [c_before, c] = matches[1:2]
   39              0.000080   endif
   39              0.001413   let plist = split(&matchpairs, '.\zs[:,]')
   39              0.000363   let i = index(plist, c)
   39              0.000136   if i < 0
                                " not found, in Insert mode try character before the cursor
   12              0.000089     if c_col > 1 && (mode() == 'i' || mode() == 'R')
    2              0.000007       let before = strlen(c_before)
    2              0.000003       let c = c_before
    2              0.000005       let i = index(plist, c)
   12              0.000015     endif
   12              0.000028     if i < 0
                                  " not found, nothing to do
   12              0.000028       return
                                endif
   27              0.000053   endif
                            
                              " Figure out the arguments for searchpairpos().
   27              0.000103   if i % 2 == 0
   23              0.000098     let s_flags = 'nW'
   23              0.000200     let c2 = plist[i + 1]
    4              0.000010   else
    4              0.000022     let s_flags = 'nbW'
    4              0.000024     let c2 = c
    4              0.000040     let c = plist[i - 1]
   27              0.000045   endif
   27              0.000116   if c == '['
                                let c = '\['
                                let c2 = '\]'
   27              0.000051   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   27              0.000096   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
   27              0.000050   endif
                            
   27              0.000516   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
   27              0.000054   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
   27              0.000321     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
   27              0.000082     try
   27              0.037605       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
   27              0.000079     endtry
   27              0.000056   endif
                            
                              " Limit the search to lines visible in the window.
   27              0.000726   let stoplinebottom = line('w$')
   27              0.000220   let stoplinetop = line('w0')
   27              0.000134   if i % 2 == 0
   23              0.000152     let stopline = stoplinebottom
    4              0.000012   else
    4              0.000034     let stopline = stoplinetop
   27              0.000067   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   27              0.000246   if mode() == 'i' || mode() == 'R'
   16              0.000193     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
   11              0.000032   else
   11              0.000221     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
   27              0.000054   endif
   27              0.000070   try
   27              0.044190     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
   27              0.000092   endtry
                            
   27              0.000114   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
   27              0.000053   endif
                            
                              " If a match is found setup match highlighting.
   27              0.000238   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
   27              0.000233     if exists('*matchaddpos')
   27              0.003443       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
   27              0.000054     endif
   27              0.000216     let w:paren_hl_on = 1
   27              0.000055   endif

FUNCTION  emmet#getIndentation()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet.vim line 39
Called 2 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    2              0.000003   if a:0 > 0
    2              0.000004     let type = a:1
                              else
                                let type = emmet#getFileType()
    2              0.000001   endif
    2              0.000010   if has_key(s:emmet_settings, type) && has_key(s:emmet_settings[type], 'indentation')
                                let indent = s:emmet_settings[type].indentation
    2              0.000004   elseif has_key(s:emmet_settings, 'indentation')
                                let indent = s:emmet_settings.indentation
    2              0.000004   elseif has_key(s:emmet_settings.variables, 'indentation')
                                let indent = s:emmet_settings.variables.indentation
    2              0.000002   else
    2              0.000008     let sw = exists('*shiftwidth') ? shiftwidth() : &l:shiftwidth
    2              0.000008     let indent = (&l:expandtab || &l:tabstop !=# sw) ? repeat(' ', sw) : "\t"
    2              0.000002   endif
    2              0.000002   return indent

FUNCTION  <SNR>207_get_tag()
    Defined: /usr/share/vim/vim81/indent/html.vim line 267
Called 1 time
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
                              "{{{
    1              0.000017   let i = get(s:indent_tags, a:tagname)
    1              0.000017   if (i == 1 || i == -1) && get(b:hi_removed_tags, a:tagname) != 0
                                return 0
    1              0.000003   endif
    1              0.000004   if i == 0
                                let i = get(b:hi_tags, a:tagname)
    1              0.000002   endif
    1              0.000005   return i

FUNCTION  emmet#lang#html#parseIntoTree()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet/lang/html.vim line 52
Called 1 time
Total time:   0.006644
 Self time:   0.001617

count  total (s)   self (s)
    1              0.000002   let abbr = a:abbr
    1              0.000002   let type = a:type
                            
    1   0.000010   0.000008   let settings = emmet#getSettings()
    1              0.000003   if !has_key(settings, type)
                                let type = 'html'
    1              0.000001   endif
    1              0.000003   if len(type) == 0 | let type = 'html' | endif
                            
    1   0.000040   0.000006   let indent = emmet#getIndentation(type)
    1              0.000009   let pmap = {'p': 'span','ul': 'li','ol': 'li','table': 'tr','tr': 'td','tbody': 'tr','thead': 'tr','tfoot': 'tr','colgroup': 'col','select': 'option','optgroup': 'option','audio': 'source','video': 'source','object': 'param','map': 'area'}
                            
    1              0.000013   let inlineLevel = split('a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var',',')
                            
    1   0.000144   0.000011   let custom_expands = emmet#getResource(type, 'custom_expands', {})
    1              0.000004   if empty(custom_expands) && has_key(settings, 'custom_expands')
    1              0.000002     let custom_expands = settings['custom_expands']
    1              0.000001   endif
                            
                              " try 'foo' to (foo-x)
    1   0.000451   0.000009   let rabbr = emmet#getExpandos(type, abbr)
    1              0.000002   if rabbr == abbr
                                " try 'foo+(' to (foo-x)
    1              0.000015     let rabbr = substitute(abbr, '\%(+\|^\)\([a-zA-Z][a-zA-Z0-9+]\+\)+\([(){}>]\|$\)', '\="(".emmet#getExpandos(type, submatch(1)).")".submatch(2)', 'i')
    1              0.000001   endif
    1              0.000001   let abbr = rabbr
                            
    1   0.000014   0.000005   let root = emmet#newNode()
    1              0.000002   let parent = root
    1              0.000002   let last = root
    1              0.000001   let pos = []
    2              0.000004   while len(abbr)
                                " parse line
    1              0.000077     let match = matchstr(abbr, s:mx)
    1              0.000065     let str = substitute(match, s:mx, '\0', 'ig')
    1              0.000059     let operator = substitute(match, s:mx, '\1', 'ig')
    1              0.000057     let block_start = substitute(match, s:mx, '\2', 'ig')
    1              0.000060     let tag_name = substitute(match, s:mx, '\3', 'ig')
    1              0.000056     let attributes = substitute(match, s:mx, '\4', 'ig')
    1              0.000060     let value = substitute(match, s:mx, '\5', 'ig')
    1              0.000056     let basevalue = substitute(match, s:mx, '\6', 'ig')
    1              0.000060     let multiplier = 0 + substitute(match, s:mx, '\7', 'ig')
    1              0.000060     let block_end = substitute(match, s:mx, '\8', 'ig')
    1              0.000002     let custom = ''
    1              0.000001     let important = 0
    1              0.000003     if len(str) == 0
                                  break
    1              0.000001     endif
    1              0.000003     if tag_name =~# '^#'
                                  let attributes = tag_name . attributes
                                  let tag_name = ''
    1              0.000001     endif
    1              0.000005     if tag_name =~# '[^!]!$'
                                  let tag_name = tag_name[:-2]
                                  let important = 1
    1              0.000000     endif
    1              0.000002     if tag_name =~# '^\.'
                                  let attributes = tag_name . attributes
                                  let tag_name = ''
    1              0.000001     endif
    1              0.000003     if tag_name =~# '^\[.*\]$'
                                  let attributes = tag_name . attributes
                                  let tag_name = ''
    1              0.000001     endif
                            
    2              0.000005     for k in keys(custom_expands)
    1              0.000004       if tag_name =~ k
                                    let custom = tag_name
                                    let tag_name = ''
                                    break
    1              0.000001       endif
    2              0.000002     endfor
                            
    1              0.000002     if empty(tag_name)
                                  let pname = len(parent.child) > 0 ? parent.child[0].name : ''
                                  if !empty(pname) && has_key(pmap, pname)
                                    let tag_name = pmap[pname]
                                  elseif !empty(pname) && index(inlineLevel, pname) > -1
                                    let tag_name = 'span'
                                  elseif len(parent.child) == 0 || len(custom) == 0
                                    let tag_name = 'div'
                                  else
                                    let tag_name = custom
                                  endif
    1              0.000001     endif
                            
    1              0.000004     let basedirect = basevalue[1] ==# '-' ? -1 : 1
    1              0.000004     let basevalue = 0 + abs(basevalue[1:])
    1              0.000004     if multiplier <= 0 | let multiplier = 1 | endif
                            
                                " make default node
    1   0.000017   0.000007     let current = emmet#newNode()
                            
    1              0.000003     let current.name = tag_name
    1              0.000002     let current.important = important
                            
                                " aliases
    1   0.001205   0.000009     let aliases = emmet#getResource(type, 'aliases', {})
    1              0.000002     if has_key(aliases, tag_name)
                                  let current.name = aliases[tag_name]
    1              0.000000     endif
                            
    1   0.000085   0.000008     let use_pipe_for_cursor = emmet#getResource(type, 'use_pipe_for_cursor', 1)
                            
                                " snippets
    1   0.000593   0.000008     let snippets = emmet#getResource(type, 'snippets', {})
    1              0.000002     if !empty(snippets)
    1              0.000002       let snippet_name = tag_name
    1              0.000002       if has_key(snippets, snippet_name)
                                    let snippet = snippet_name
                                    while has_key(snippets, snippet)
                                      let snippet = snippets[snippet]
                                    endwhile
                                    if use_pipe_for_cursor
                                      let snippet = substitute(snippet, '|', '${cursor}', 'g')
                                    endif
                                    " just redirect to expanding
                                    if type == 'html' && snippet !~ '^\s*[{\[<]'
                                       return emmet#lang#html#parseIntoTree(snippet, a:type)
                                    endif
                                    let lines = split(snippet, "\n", 1)
                                    call map(lines, 'substitute(v:val, "\\(    \\|\\t\\)", escape(indent, "\\\\"), "g")')
                                    let current.snippet = join(lines, "\n")
                                    let current.name = ''
    1              0.000000       endif
    1              0.000000     endif
                            
    2              0.000003     for k in keys(custom_expands)
    1              0.000005       if tag_name =~# k
                                    let current.snippet = '${' . (empty(custom) ? tag_name : custom) . '}'
                                    let current.name = ''
                                    break
    1              0.000004       elseif custom =~# k
                                    let current.snippet = '${' . custom . '}'
                                    let current.name = ''
                                    break
    1              0.000000       endif
    2              0.000001     endfor
                            
                                " default_attributes
    1   0.002550   0.000011     let default_attributes = emmet#getResource(type, 'default_attributes', {})
    1              0.000003     if !empty(default_attributes)
    3              0.000003       for pat in [current.name, tag_name]
    2              0.000006         if has_key(default_attributes, pat)
                                      if type(default_attributes[pat]) == 4
                                        let a = default_attributes[pat]
                                        let current.attrs_order += keys(a)
                                        if use_pipe_for_cursor
                                          for k in keys(a)
                                            let current.attr[k] = len(a[k]) ? substitute(a[k], '|', '${cursor}', 'g') : '${cursor}'
                                          endfor
                                        else
                                          for k in keys(a)
                                            let current.attr[k] = a[k]
                                          endfor
                                        endif
                                      else
                                        for a in default_attributes[pat]
                                          let current.attrs_order += keys(a)
                                          if use_pipe_for_cursor
                                            for k in keys(a)
                                              let current.attr[k] = len(a[k]) ? substitute(a[k], '|', '${cursor}', 'g') : '${cursor}'
                                            endfor
                                          else
                                            for k in keys(a)
                                              let current.attr[k] = a[k]
                                            endfor
                                          endif
                                        endfor
                                      endif
                                      if has_key(settings.html.default_attributes, current.name)
                                        let current.name = substitute(current.name, ':.*$', '', '')
                                      endif
                                      break
    2              0.000001         endif
    3              0.000001       endfor
    1              0.000000     endif
                            
                                " parse attributes
    1              0.000002     if len(attributes)
                                  let attr = attributes
                                  while len(attr)
                                    let item = matchstr(attr, '\(\%(\%(#[{}a-zA-Z0-9_\-\$]\+\)\|\%(\[\%("[^"]*"\|[^"\]]*\)\+\]\)\|\%(\.[{}a-zA-Z0-9_\-\$]\+\)*\)\)')
                                    if g:emmet_debug > 1
                                      echomsg 'attr=' . item
                                    endif
                                    if len(item) == 0
                                      break
                                    endif
                                    if item[0] ==# '#'
                                      let current.attr.id = item[1:]
                                    endif
                                    if item[0] ==# '.'
                                      let current.attr.class = substitute(item[1:], '\.', ' ', 'g')
                                    endif
                                    if item[0] ==# '['
                                      let atts = item[1:-2]
                                      if matchstr(atts, '^\s*\zs[0-9a-zA-Z_\-:]\+\(="[^"]*"\|=''[^'']*''\|=[^ ''"]\+\)') ==# ''
                                        let ks = []
                            			if has_key(default_attributes, current.name)
                                          let dfa = default_attributes[current.name]
                                          let ks = type(dfa) == 3 ? len(dfa) > 0 ? keys(dfa[0]) : [] : keys(dfa)
                                        endif
                                        if len(ks) == 0 && has_key(default_attributes, current.name . ':src')
                                          let dfa = default_attributes[current.name . ':src']
                                          let ks = type(dfa) == 3 ? len(dfa) > 0 ? keys(dfa[0]) : [] : keys(dfa)
                                        endif
                                        if len(ks) > 0
                                          let current.attr[ks[0]] = atts
                                        else
                                          let current.attr[atts] = ''
                                        endif
                                      else
                                        while len(atts)
                                          let amat = matchstr(atts, '^\s*\zs\([0-9a-zA-Z-:]\+\%(={{.\{-}}}\|="[^"]*"\|=''[^'']*''\|=[^ ''"]\+\|[^ ''"\]]*\)\{0,1}\)')
                                          if len(amat) == 0
                                            break
                                          endif
                                          let key = split(amat, '=')[0]
                                          let Val = amat[len(key)+1:]
                                          if key =~# '\.$' && Val ==# ''
                                            let key = key[:-2]
                                            unlet Val
                                            let Val = function('emmet#types#true')
                                          elseif Val =~# '^["'']'
                                            let Val = Val[1:-2]
                                          endif
                                          let current.attr[key] = Val
                                          if index(current.attrs_order, key) == -1
                                            let current.attrs_order += [key]
                                          endif
                                          let atts = atts[stridx(atts, amat) + len(amat):]
                                          unlet Val
                                        endwhile
                                      endif
                                    endif
                                    let attr = substitute(strpart(attr, len(item)), '^\s*', '', '')
                                  endwhile
    1              0.000001     endif
                            
                                " parse text
    1              0.000003     if tag_name =~# '^{.*}$'
                                  let current.name = ''
                                  let current.value = tag_name
    1              0.000000     else
    1              0.000002       let current.value = value
    1              0.000001     endif
    1              0.000002     let current.basedirect = basedirect
    1              0.000002     let current.basevalue = basevalue
    1              0.000002     let current.multiplier = multiplier
                            
                                " parse step inside/outside
    1              0.000002     if !empty(last)
    1              0.000002       if operator =~# '>'
                                    unlet! parent
                                    let parent = last
                                    let current.parent = last
                                    let current.pos = last.pos + 1
    1              0.000000       else
    1              0.000001         let current.parent = parent
    1              0.000001         let current.pos = last.pos
    1              0.000001       endif
                                else
                                  let current.parent = parent
                                  let current.pos = 1
    1              0.000001     endif
    1              0.000003     if operator =~# '[<^]'
                                  for c in range(len(operator))
                                    let tmp = parent.parent
                                    if empty(tmp)
                                      break
                                    endif
                                    let parent = tmp
                                    let current.parent = tmp
                                  endfor
    1              0.000000     endif
                            
    1              0.000003     call add(parent.child, current)
    1              0.000001     let last = current
                            
                                " parse block
    1              0.000002     if block_start =~# '('
                                  if operator =~# '>'
                                    let last.pos += 1
                                  endif
                                  let last.block = 1
                                  for n in range(len(block_start))
                                    let pos += [last.pos]
                                  endfor
    1              0.000001     endif
    1              0.000002     if block_end =~# ')'
                                  for n in split(substitute(substitute(block_end, ' ', '', 'g'), ')', ',),', 'g'), ',')
                                    if n ==# ')'
                                      if len(pos) > 0 && last.pos >= pos[-1]
                                        for c in range(last.pos - pos[-1])
                                          let tmp = parent.parent
                                          if !has_key(tmp, 'parent')
                                            break
                                          endif
                                          let parent = tmp
                                        endfor
                                        if len(pos) > 0
                                          call remove(pos, -1)
                                        endif
                                        let last = parent
                                        let last.pos += 1
                                      endif
                                    elseif len(n)
                                      let st = 0
                                      for nc in range(len(last.child))
                                        if last.child[nc].block
                                          let st = nc
                                          break
                                        endif
                                      endfor
                                      let cl = last.child[st :]
                                      let cls = []
                                      for c in range(n[1:])
                                        for cc in cl
                                          if cc.multiplier > 1
                                            let cc.basedirect = c + 1
                                          else
                                            let cc.basevalue = c + 1
                                          endif
                                        endfor
                                        let cls += deepcopy(cl)
                                      endfor
                                      if st > 0
                                        let last.child = last.child[:st-1] + cls
                                      else
                                        let last.child = cls
                                      endif
                                    endif
                                  endfor
    1              0.000000     endif
    1              0.000006     let abbr = abbr[stridx(abbr, match) + len(match):]
    1              0.000002     if abbr == '/'
                                  let current.empty = 1
    1              0.000000     endif
                            
    1              0.000002     if g:emmet_debug > 1
                                  echomsg 'str='.str
                                  echomsg 'block_start='.block_start
                                  echomsg 'tag_name='.tag_name
                                  echomsg 'operator='.operator
                                  echomsg 'attributes='.attributes
                                  echomsg 'value='.value
                                  echomsg 'basevalue='.basevalue
                                  echomsg 'multiplier='.multiplier
                                  echomsg 'block_end='.block_end
                                  echomsg 'abbr='.abbr
                                  echomsg 'pos='.string(pos)
                                  echomsg '---'
    1              0.000000     endif
    2              0.000005   endwhile
    1              0.000002   return root

FUNCTION  emmet#expandDollarExpr()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet.vim line 483
Called 1 time
Total time:   0.000319
 Self time:   0.000010

count  total (s)   self (s)
    1   0.000319   0.000010   return emmet#reExpandDollarExpr(a:expand, 0)

FUNCTION  emmet#getSettings()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet.vim line 301
Called 4 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    4              0.000008   return s:emmet_settings

FUNCTION  emmet#lang#type()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet/lang.vim line 12
Called 3 times
Total time:   0.000373
 Self time:   0.000072

count  total (s)   self (s)
    3              0.000005   let type = a:type
    3              0.000005   let base = type
    3   0.000022   0.000016   let settings = emmet#getSettings()
    3              0.000007   while base != ''
    3              0.000014     for b in split(base, '\.')
    3   0.000313   0.000018       if emmet#lang#exists(b)
    3              0.000003         return b
                                  endif
                                  if has_key(settings, b) && has_key(settings[b], 'extends')
                                    let base = settings[b].extends
                                    break
                                  else
                                    let base = ''
                                  endif
                                endfor
                              endwhile
                              return 'html'

FUNCTION  <SNR>207_CountITags()
    Defined: /usr/share/vim/vim81/indent/html.vim line 280
Called 1 time
Total time:   0.000537
 Self time:   0.000192

count  total (s)   self (s)
                              "{{{
                              " Store the result in s:curind and s:nextrel.
    1              0.000011   let s:curind = 0  " relative indent steps for current line [unit &sw]:
    1              0.000007   let s:nextrel = 0  " relative indent steps for next line [unit &sw]:
    1              0.000007   let s:block = 0		" assume starting outside of a block
    1              0.000007   let s:countonly = 1	" don't change state
    1   0.000486   0.000141   call substitute(a:text, '<\zs/\=' . s:tagname . '\>\|<!--\[\|\[endif\]-->\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
    1              0.000008   let s:countonly = 0

FUNCTION  <SNR>99_parse_screen()
    Defined: ~/.vim/bundle/vim-css-color/autoload/css_color.vim line 226
Called 26 times
Total time:   0.078523
 Self time:   0.077625

count  total (s)   self (s)
   26   0.001188   0.000582 	call s:clear_matches()
   26              0.000334 	let leftcol = winsaveview().leftcol
   26              0.000282 	let left = max([ leftcol - 15, 0 ])
   26              0.000163 	let width = &columns * 4
   26              0.075562 	call filter( range( line('w0'), line('w$') ), 'substitute( strpart( getline(v:val), col([v:val, left]), width ), b:css_color_pat, ''\=s:create_syn_match()'', ''g'' )' )
   26   0.000885   0.000593 	call s:create_matches()

FUNCTION  <SNR>30_record()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim line 59
Called 3 times
Total time:   0.001418
 Self time:   0.000431

count  total (s)   self (s)
    3              0.000053 	if s:locked | retu | en
    3              0.000033 	let bufnr = a:bufnr + 0
    3              0.000040 	let bufname = bufname(bufnr)
    3              0.000035 	if bufnr > 0 && !empty(bufname)
    3              0.000074 		cal filter(s:mrbs, 'v:val != bufnr')
    3              0.000033 		cal insert(s:mrbs, bufnr)
    3   0.001124   0.000137 		cal s:addtomrufs(bufname)
    3              0.000007 	en

FUNCTION  emmet#expandCursorExpr()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet.vim line 487
Called 1 time
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    1              0.000002   let expand = a:expand
    1              0.000003   if expand !~# '\${cursor}'
                                if a:mode ==# 2
                                  let expand = '${cursor}' . expand
                                else
                                  let expand .= '${cursor}'
                                endif
    1              0.000000   endif
    1              0.000009   let expand = substitute(expand, '\${\d\+:\?\([^}]\+\)}', '$select$$cursor$\1$select$', 'g')
    1              0.000006   let expand = substitute(expand, '\${\d\+}', '$select$$cursor$$select$', 'g')
    1              0.000005   let expand = substitute(expand, '\${cursor}', '$cursor$', '')
    1              0.000005   let expand = substitute(expand, '\${cursor}', '', 'g')
    1              0.000004   let expand = substitute(expand, '\${cursor}', '', 'g')
    1              0.000001   return expand

FUNCTION  <SNR>30_addtomrufs()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim line 70
Called 3 times
Total time:   0.000987
 Self time:   0.000987

count  total (s)   self (s)
    3              0.000125 	let fn = fnamemodify(a:fname, get(g:, 'ctrlp_tilde_homedir', 0) ? ':p:~' : ':p')
    3              0.000096 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
    3              0.000055 	let abs_fn = fnamemodify(fn,':p')
    3              0.000451 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^' . abs_fn . '$', '&bt')) || !filereadable(abs_fn)
                            		retu
    3              0.000007 	en
    3              0.000077 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
    3              0.000012 	if idx
                            		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
                            		cal insert(s:mrufs, fn)
                            		if {s:soup} && idx < 0
                            			cal s:savetofile(s:mergelists())
                            		en
    3              0.000007 	en

FUNCTION  <SNR>30_chop()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim line 38
Called 1 time
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    1              0.000034 	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
    1              0.000007 	retu a:mrufs

FUNCTION  emmet#util#unique()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet/util.vim line 301
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000001   let m = {}
    1              0.000002   let r = []
    3              0.000004   for i in a:arr
    2              0.000004     if !has_key(m, i)
    2              0.000004       let m[i] = 1
    2              0.000004       call add(r, i)
    2              0.000001     endif
    3              0.000002   endfor
    1              0.000001   return r

FUNCTION  <SNR>207_CountTagsAndState()
    Defined: /usr/share/vim/vim81/indent/html.vim line 292
Called 1 time
Total time:   0.000149
 Self time:   0.000149

count  total (s)   self (s)
                              "{{{
                              " Store the result in s:curind and s:nextrel.  Update b:hi_newstate.block.
    1              0.000008   let s:curind = 0  " relative indent steps for current line [unit &sw]:
    1              0.000006   let s:nextrel = 0  " relative indent steps for next line [unit &sw]:
                            
    1              0.000009   let s:block = b:hi_newstate.block
    1              0.000081   let tmp = substitute(a:text, '<\zs/\=' . s:tagname . '\>\|<!--\[\|\[endif\]-->\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
    1              0.000007   if s:block == 3
                                let b:hi_newstate.scripttype = s:GetScriptType(matchstr(tmp, '\C.*<SCRIPT\>\zs[^>]*'))
    1              0.000003   endif
    1              0.000010   let b:hi_newstate.block = s:block

FUNCTION  emmet#useFilter()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet.vim line 28
Called 4 times
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
    8              0.000013   for f in a:filters
    4              0.000007     if a:filter ==# '/' && f =~# '^/'
                                  return 1
    4              0.000006     elseif f ==# a:filter
                                  return 1
    4              0.000002     endif
    8              0.000006   endfor
    4              0.000004   return 0

FUNCTION  emmet#getExpandos()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet.vim line 11
Called 1 time
Total time:   0.000442
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000436   0.000008   let expandos = emmet#getResource(a:type, 'expandos', {})
    1              0.000002   if has_key(expandos, a:key)
                                return expandos[a:key]
    1              0.000000   endif
    1              0.000002   return a:key

FUNCTION  emmet#lang#exists()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet/lang.vim line 2
Called 7 times
Total time:   0.000622
 Self time:   0.000622

count  total (s)   self (s)
    7              0.000019   if len(a:type) == 0
                                return 0
    7              0.000016   elseif has_key(s:exists, a:type)
    5              0.000010     return s:exists[a:type]
    2              0.000001   endif
    2              0.000555   let s:exists[a:type] = len(globpath(&rtp, 'autoload/emmet/lang/'.a:type.'.vim')) > 0
    2              0.000005   return s:exists[a:type]

FUNCTION  emmet#getBaseType()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet.vim line 58
Called 3 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    3              0.000010   if !has_key(s:emmet_settings, a:type)
    3              0.000003     return ''
                              endif
                              if !has_key(s:emmet_settings[a:type], 'extends')
                                return a:type
                              endif
                              let extends = s:emmet_settings[a:type].extends
                              if type(extends) ==# 1
                                let tmp = split(extends, '\s*,\s*')
                                let ext = tmp[0]
                              else
                                let ext = extends[0]
                              endif
                              if a:type !=# ext
                                return emmet#getBaseType(ext)
                              endif
                              return ''

FUNCTION  <SNR>207_CheckCustomTag()
    Defined: /usr/share/vim/vim81/indent/html.vim line 369
Called 1 time
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
                              "{{{
                              " Returns 1 if ctag is the tag for a custom element, 0 otherwise.
                              " a:ctag can be "tag" or "/tag" or "<!--" or "-->"
    1              0.000009   let pattern = '\%\(\w\+-\)\+\w\+'
    1              0.000055   if match(a:ctag, pattern) == -1
    1              0.000006     return 0
                              endif
                              if matchstr(a:ctag, '\/\ze.\+') == "/"
                                " closing tag
                                if s:block != 0
                                  " ignore ctag within a block
                                  return 1
                                endif
                                if s:nextrel == 0
                                  let s:curind -= 1
                                else
                                  let s:nextrel -= 1
                                endif
                              else
                                " opening tag
                                if s:block != 0
                                  return 1
                                endif
                                let s:nextrel += 1
                              endif
                              return 1

FUNCTION  emmet#mergeConfig()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet.vim line 127
Called 4 times
Total time:   0.004413
 Self time:   0.004413

count  total (s)   self (s)
    4              0.000013   let [lhs, rhs] = [a:lhs, a:rhs]
    4              0.000008   if type(lhs) ==# 3
                                if type(rhs) ==# 3
                                  let lhs += rhs
                                  if len(lhs)
                                    call remove(lhs, 0, len(lhs)-1)
                                  endif
                                  for rhi in rhs
                                    call add(lhs, rhs[rhi])
                                  endfor
                                elseif type(rhs) ==# 4
                                  let lhs += map(keys(rhs), '{v:val : rhs[v:val]}')
                                endif
    4              0.000008   elseif type(lhs) ==# 4
    4              0.000004     if type(rhs) ==# 3
                                  for V in rhs
                                    if type(V) != 4
                                      continue
                                    endif
                                    for k in keys(V)
                                      let lhs[k] = V[k]
                                    endfor
                                  endfor
    4              0.000008     elseif type(rhs) ==# 4
  158              0.000171       for key in keys(rhs)
  154              0.000311         if type(rhs[key]) ==# 3
   84              0.000145           if !has_key(lhs, key)
   84              0.000165             let lhs[key] = []
   84              0.000054           endif
   84              0.000166           if type(lhs[key]) == 3
   84              0.000184             let lhs[key] += rhs[key]
                                      elseif type(lhs[key]) == 4
                                        for k in keys(rhs[key])
                                          let lhs[key][k] = rhs[key][k]
                                        endfor
   84              0.000047           endif
   70              0.000136         elseif type(rhs[key]) ==# 4
    1              0.000002           if has_key(lhs, key)
                                        call emmet#mergeConfig(lhs[key], rhs[key])
    1              0.000001           else
    1              0.000002             let lhs[key] = rhs[key]
    1              0.000000           endif
   69              0.000041         else
   69              0.000142           let lhs[key] = rhs[key]
  154              0.000097         endif
  158              0.000109       endfor
    4              0.000003     endif
    4              0.000003   endif

FUNCTION  emmet#getDollarValueByKey()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet.vim line 442
Called 1 time
Total time:   0.000157
 Self time:   0.000066

count  total (s)   self (s)
    1              0.000002   let ret = 0
    1              0.000002   let key = a:key
    1   0.000101   0.000010   let ftsetting = get(s:emmet_settings, emmet#getFileType())
    1              0.000004   if type(ftsetting) ==# 4 && has_key(ftsetting, key)
                                let V = get(ftsetting, key)
                                if type(V) ==# 1 | return V | endif
    1              0.000001   endif
    1              0.000004   if type(ret) !=# 1 && has_key(s:emmet_settings.variables, key)
                                let V = get(s:emmet_settings.variables, key)
                                if type(V) ==# 1 | return V | endif
    1              0.000001   endif
    1              0.000004   if has_key(s:emmet_settings, 'custom_expands') && type(s:emmet_settings['custom_expands']) ==# 4
    2              0.000004     for k in keys(s:emmet_settings['custom_expands'])
    1              0.000004       if key =~# k
                                    let V = get(s:emmet_settings['custom_expands'], k)
                                    if type(V) ==# 1 | return V | endif
                                    if type(V) ==# 2 | return V(key) | endif
    1              0.000001       endif
    2              0.000001     endfor
    1              0.000001   endif
    1              0.000001   return ret

FUNCTION  emmet#util#closePopup()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet/util.vim line 347
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000005   return pumvisible() ? "\<c-e>" : ''

FUNCTION  ctrlp#utils#readfile()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim line 44
Called 1 time
Total time:   0.000231
 Self time:   0.000231

count  total (s)   self (s)
    1              0.000045 	if filereadable(a:file)
    1              0.000141 		let data = readfile(a:file)
    1              0.000020 		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
    1              0.000003 		en
    1              0.000005 		retu data
                            	en
                            	retu []

FUNCTION  <SNR>99_create_matches()
    Defined: ~/.vim/bundle/vim-css-color/autoload/css_color.vim line 190
Called 26 times
Total time:   0.000292
 Self time:   0.000292

count  total (s)   self (s)
   26              0.000247 	if ! &l:cursorline | return | endif
                            	" adds matches based that duplicate the highlighted colors on the current line
                            	let lnr = line('.')
                            	let group = ''
                            	let groupstart = 0
                            	let endcol = col('$')
                            	let w:color_match_id = []
                            	for col in range( 1, endcol )
                            		let nextgroup = col < endcol ? synIDattr( synID( lnr, col, 1 ), 'name' ) : ''
                            		if group == nextgroup | continue | endif
                            		if group =~ '^BG\x\{6}$'
                            			let regex = '\%'.lnr.'l\%'.groupstart.'c'.repeat( '.', col - groupstart )
                            			let match = matchadd( group, regex, -1 )
                            			let w:color_match_id += [ match ]
                            		endif
                            		let group = nextgroup
                            		let groupstart = col
                            	endfor

FUNCTION  ctrlp#utils#mkdir()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim line 56
Called 1 time
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    1              0.000029 	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
    1              0.000003 	en
    1              0.000007 	retu a:dir

FUNCTION  GetVueIndent()
    Defined: ~/.vim/bundle/vim-vue/indent/vue.vim line 43
Called 1 time
Total time:   0.004202
 Self time:   0.000777

count  total (s)   self (s)
    6              0.000062   for language in s:languages
    5              0.000404     let opening_tag_line = searchpair(language.pairs[0], '', language.pairs[1], 'bWr')
                            
    5              0.000055     if opening_tag_line
                                  execute 'let indent = ' . get(language, 'indentexpr', -1)
                                  break
    5              0.000012     endif
    6              0.000021   endfor
                            
    1              0.000013   if exists('l:indent')
                                if (opening_tag_line == prevnonblank(v:lnum - 1) || opening_tag_line == v:lnum) || getline(v:lnum) =~ '\v^\s*\</(script|style|template)'
                                  return 0
                                endif
    1              0.000003   else
                                " Couldn't find language, fall back to html
    1   0.003472   0.000047     execute 'let indent = ' . s:html_indent
    1              0.000003   endif
                            
    1              0.000005   return indent

FUNCTION  emmet#getFileType()
    Defined: ~/.vim/bundle/emmet-vim/autoload/emmet.vim line 372
Called 3 times
Total time:   0.000699
 Self time:   0.000311

count  total (s)   self (s)
    3              0.000010   let flg = get(a:000, 0, 0)
    3              0.000004   let type = ''
                            
    3              0.000009   if has_key(s:emmet_settings, &filetype)
                                let type = &filetype
    3              0.000003   else
    3              0.000017     let types = split(&filetype, '\.')
    6              0.000010     for part in types
    3   0.000457   0.000084       if emmet#lang#exists(part)
                                    let type = part
                                    break
    3              0.000001       endif
    3   0.000036   0.000021       let base = emmet#getBaseType(part)
    3              0.000003       if base !=# ''
                                    if flg
                                      let type = &filetype
                                    else
                                      let type = base
                                    endif
                                    unlet base
                                    break
    3              0.000002       endif
    6              0.000006     endfor
    3              0.000002   endif
    3              0.000004   if type ==# 'html'
                                let pos = emmet#util#getcurpos()
                                let type = synIDattr(synID(pos[1], pos[2], 1), 'name')
                                if type =~# '^css\w'
                                  let type = 'css'
                                endif
                                if type =~# '^html\w'
                                  let type = 'html'
                                endif
                                if type =~# '^javaScript'
                                  let type = 'javascript'
                                endif
                                if len(type) ==# 0 && type =~# '^xml'
                                  let type = 'xml'
                                endif
    3              0.000002   endif
    3              0.000011   if len(type) ==# 0 | let type = 'html' | endif
    3              0.000003   return type

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   39   0.108328             <SNR>43_Highlight_Matching_Pair()
   26   0.078523   0.077625  <SNR>99_parse_screen()
    1   0.028006   0.000041  <SNR>30_savetofile()
    1   0.027965   0.027911  ctrlp#utils#writecache()
    1   0.011106   0.000702  emmet#expandAbbr()
    1   0.006716   0.000036  emmet#parseIntoTree()
    1   0.006644   0.001617  emmet#lang#html#parseIntoTree()
   14   0.005726   0.001313  emmet#getResource()
    4   0.004413             emmet#mergeConfig()
    1   0.004202   0.000777  GetVueIndent()
    1   0.003425   0.001148  HtmlIndent()
    1   0.002128   0.001411  <SNR>207_FreshState()
    3   0.001418   0.000431  <SNR>30_record()
    1   0.001227   0.000250  emmet#toString()
    3   0.000987             <SNR>30_addtomrufs()
    1   0.000859   0.000373  emmet#lang#html#toString()
    1   0.000726   0.000388  <SNR>30_mergelists()
    3   0.000699   0.000311  emmet#getFileType()
   27   0.000651             <SNR>99_clear_matches()
    7   0.000622             emmet#lang#exists()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   39              0.108328  <SNR>43_Highlight_Matching_Pair()
   26   0.078523   0.077625  <SNR>99_parse_screen()
    1   0.027965   0.027911  ctrlp#utils#writecache()
    4              0.004413  emmet#mergeConfig()
    1   0.006644   0.001617  emmet#lang#html#parseIntoTree()
    1   0.002128   0.001411  <SNR>207_FreshState()
   14   0.005726   0.001313  emmet#getResource()
    1   0.003425   0.001148  HtmlIndent()
    3              0.000987  <SNR>30_addtomrufs()
    1   0.004202   0.000777  GetVueIndent()
    1   0.011106   0.000702  emmet#expandAbbr()
   27              0.000651  <SNR>99_clear_matches()
    7              0.000622  emmet#lang#exists()
    3   0.001418   0.000431  <SNR>30_record()
    1   0.000726   0.000388  <SNR>30_mergelists()
    1   0.000859   0.000373  emmet#lang#html#toString()
    3   0.000699   0.000311  emmet#getFileType()
   26              0.000292  <SNR>99_create_matches()
    1              0.000255  emmet#lang#html#findTokens()
    1   0.001227   0.000250  emmet#toString()

